<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>DD4hep In FCCSW</title>
  <meta name="description" content="Main page for documentation and resources.">

  <link rel="stylesheet" href="http://fccsw.web.cern.ch/fccsw/css/main.css">
  <link rel="canonical" href="http://fccsw.web.cern.ch/fccsw/tutorials/FCCSW/Detector/doc/DD4hepInFCCSW.html">
  <link rel="alternate" type="application/rss+xml" title="FCCSW" href="http://fccsw.web.cern.ch/fccsw/feed.xml">
</head>


  <body>

    
<header>
   <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://fccsw.web.cern.ch/fccsw/index.html">FCCSW</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li ><a href="http://fccsw.web.cern.ch/fccsw/index.html">Home</a></li>
            <li  class="active" ><a href="http://fccsw.web.cern.ch/fccsw/tutorials">Tutorials</a></li>
            <li><a>Latest Releases:</a></li>
            
            
              
              <li >
                <a href="http://fccsw.web.cern.ch/fccsw/2017/05/15/version081.html">FCCSW v0.8.1</a>
              </li>
              
            
              
              <li >
                <a href="http://fccsw.web.cern.ch/fccsw/2017/03/29/version08.html">FCCSW v0.8</a>
              </li>
              
            
            <li ><a href="http://fccsw.web.cern.ch/fccsw/snapshot.html">Snapshot</a></li>
          </ul>
          <form class="navbar-form navbar-right">
            <div class="input-group">
            <span class="input-group-addon" id="basic-addon1"><span class="glyphicon glyphicon-search" aria-hidden="true"></span></span>
            <input type="text" class="form-control" id="search-input" placeholder="Search" aria-describedby="basic-addon1">
            </div>
          </form>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

</header>
<div class="container">
  <div class="collapse panel panel-default" id="resultswrap">
      <div class="panel-heading">Search Results <button type="button" class="close" aria-label="Close"><span aria-hidden="true" onclick="$('#resultswrap').collapse('hide');">&times;</span></button></div>
      <ul id="searchresults" class="list-group">
      </ul>
  </div>
</div>

    
    
    <div class="container">
      <div class="col-md-10">
        <h1 id="dd4hep-detector-description">DD4hep Detector Description</h1>

<h3 id="table-of-contents">Table of contents:</h3>

<ul>
  <li><a href="#ingredients-describing-a-detector">Ingredients Describing a Detector</a></li>
  <li><a href="#constructing-detector-geometry">Constructing Detector Geometry</a></li>
  <li><a href="#a-minimal-working-example">A Minimal Working Example</a></li>
  <li><a href="#sensitive-detectors">Sensitive Detectors</a>
    <ul>
      <li><a href="#using-an-existing-sensitive-detector-definition">Using an Existing Sensitive Detector Definition</a></li>
      <li><a href="#readout-definition">Readout Definition</a></li>
      <li><a href="#user-defined-sensitive-detectors">User-defined Sensitive Detectors</a></li>
      <li><a href="#segmentation">Segmentation</a></li>
    </ul>
  </li>
  <li><a href="#coordinate-conventions">Coordinate Conventions</a></li>
  <li><a href="#visualisation">Visualisation</a></li>
  <li><a href="#fccsw-folder-structure">FCCSW Folder Structure</a>
    <ul>
      <li><a href="#the-master-xmls">The master XMLs</a></li>
      <li><a href="#sub-detector-descriptions">Sub-detector descriptions</a> (please read if you plan to contribute)</li>
      <li><a href="#common-descriptions">Common descriptions</a></li>
    </ul>
  </li>
  <li><a href="#material-budget-estimation">Material budget estimation</a></li>
  <li><a href="#troubleshooting">Troubleshooting</a></li>
</ul>

<h2 id="ingredients-describing-a-detector">Ingredients Describing a Detector</h2>

<p>To first order two files are involved to describe a detector in DD4hep.</p>

<ul>
  <li>The xml-based detector description that defines the dimensions and materials of the detector</li>
  <li>The macro that implements the factory method to construct the detector from the xml-description</li>
</ul>

<h2 id="constructing-detector-geometry">Constructing Detector Geometry</h2>

<p>Similarly to Geant4 itself, DD4hep tries to re-use detector elements without having to keep every instance in memory. I.e. many <code class="highlighter-rouge">DD4hep::Geometry::PlacedVolume</code> are used that refer to one <code class="highlighter-rouge">DD4hep::Geometry::Volume</code>. To exploit this feature as much as possible:</p>

<ul>
  <li>Come up with the largest component that is repeatable (e.g. a detector wedge)
    <ul>
      <li>Usually this component is similar or equal to the components that are built when physically building the detector</li>
    </ul>
  </li>
  <li>Construct this component once and then place it several times to construct the whole detector</li>
  <li>This should minimise the number of fully unique volumes you create</li>
</ul>

<h2 id="a-minimal-working-example">A Minimal Working Example</h2>

<p>Imagine we want to create a simple cone with a radius of 1 m and a length of 1 m. Also see <a href="#coordinate-conventions">Coordinate Conventions</a> for some explanations on lengths and coordinates in DD4hep and Geant4. Note that in the following all numbers are accompanied with units to explicitly state what you mean.</p>

<ul>
  <li><strong>Detector description</strong>: First we describe the world (or a box around the sub-detector) and sub-detector in an XML:</li>
</ul>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;lccdd</span> <span class="na">xmlns:compact=</span><span class="s">"http://www.lcsim.org/schemas/compact/1.0"</span>
        <span class="na">xmlns:xs=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span>
        <span class="na">xs:noNamespaceSchemaLocation=</span><span class="s">"http://www.lcsim.org/schemas/compact/1.0/compact.xsd"</span><span class="nt">&gt;</span>

  <span class="c">&lt;!-- use DD4hep elements and material definitions: --&gt;</span>
  <span class="nt">&lt;includes&gt;</span>
    <span class="nt">&lt;gdmlFile</span>  <span class="na">ref=</span><span class="s">"elements.xml"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;gdmlFile</span>  <span class="na">ref=</span><span class="s">"materials.xml"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;/includes&gt;</span>

  <span class="c">&lt;!-- some information about your detector: --&gt;</span>
  <span class="nt">&lt;info</span> <span class="na">name=</span><span class="s">"ExampleDetector"</span>
    <span class="na">title=</span><span class="s">"This is just an example"</span>
    <span class="na">author=</span><span class="s">"T. Test"</span>
    <span class="na">url=</span><span class="s">"no"</span>
    <span class="na">status=</span><span class="s">"development"</span>
    <span class="na">version=</span><span class="s">"1.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;comment&gt;</span>This is really just a test!<span class="nt">&lt;/comment&gt;</span>
  <span class="nt">&lt;/info&gt;</span>

    <span class="c">&lt;!-- this defines the dimensions of the world volume (i.e. top level volume), generated by DD4hep automatically: --&gt;</span>
    <span class="nt">&lt;define&gt;</span>
      <span class="nt">&lt;constant</span> <span class="na">name=</span><span class="s">"world_size"</span> <span class="na">value=</span><span class="s">"80*m"</span><span class="nt">/&gt;</span> <span class="c">&lt;!-- make sure to always use units --&gt;</span>
      <span class="nt">&lt;constant</span> <span class="na">name=</span><span class="s">"world_x"</span> <span class="na">value=</span><span class="s">"world_size"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;constant</span> <span class="na">name=</span><span class="s">"world_y"</span> <span class="na">value=</span><span class="s">"world_size"</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;constant</span> <span class="na">name=</span><span class="s">"world_z"</span> <span class="na">value=</span><span class="s">"world_size"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/define&gt;</span>

  <span class="c">&lt;!-- this is where we actually define our detector: --&gt;</span>
  <span class="nt">&lt;detectors&gt;</span>
    <span class="nt">&lt;detector</span> <span class="na">id=</span><span class="s">"0"</span> <span class="na">name=</span><span class="s">"Name"</span> <span class="na">type=</span><span class="s">"Example"</span><span class="nt">&gt;</span> <span class="c">&lt;!-- note that the type is important, see below --&gt;</span>
      <span class="nt">&lt;dimensions</span> <span class="na">rmin1=</span><span class="s">"0"</span> <span class="na">rmax1=</span><span class="s">"1*m"</span> <span class="na">rmin2=</span><span class="s">"0"</span> <span class="na">rmax2=</span><span class="s">"2*m"</span> <span class="na">dz=</span><span class="s">"1*m"</span> <span class="na">material=</span><span class="s">"Aluminum"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/detector&gt;</span>
  <span class="nt">&lt;/detectors&gt;</span>
<span class="nt">&lt;/lcdd&gt;</span>
</code></pre>
</div>

<ul>
  <li><strong>Factory method</strong>: Now we define a method that actually creates the geometry of the sub-detector, the <code class="highlighter-rouge">type</code> given in the xml tells DD4hep which factory method to call for a detector (see the very end of this snippet):</li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">detector</span> <span class="p">{</span>
<span class="k">static</span> <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Ref_t</span> <span class="n">createElement</span><span class="p">(</span>
  <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">LCDD</span><span class="o">&amp;</span> <span class="n">lcdd</span><span class="p">,</span>                 <span class="c1">// dd4hep's main detector description interface
</span>  <span class="n">xml_h</span> <span class="n">xmlElement</span><span class="p">,</span>                             <span class="c1">// the xml-tree that describes this detector
</span>  <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">SensitiveDetector</span> <span class="n">sensDet</span>   <span class="c1">// dd4hep's interface to the sensitive detector
</span>  <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Get the detector description from the xml-tree
</span>    <span class="n">xml_det_t</span>    <span class="n">x_det</span> <span class="o">=</span> <span class="n">xml_h</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span>  <span class="n">name</span>  <span class="o">=</span> <span class="n">x_det</span><span class="p">.</span><span class="n">nameStr</span><span class="p">();</span>
    <span class="c1">// Create the detector element
</span>    <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">DetElement</span>   <span class="n">coneDet</span><span class="p">(</span> <span class="n">name</span><span class="p">,</span> <span class="n">x_det</span><span class="p">.</span><span class="n">id</span><span class="p">()</span> <span class="p">);</span>
    <span class="c1">// Get the world volume
</span>    <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Volume</span> <span class="n">experimentalHall</span> <span class="o">=</span>  <span class="n">lcdd</span><span class="p">.</span><span class="n">pickMotherVolume</span><span class="p">(</span> <span class="n">coneDet</span> <span class="p">);</span>  <span class="c1">// gets the containing volume (i.e. the world volume in this case)
</span>    <span class="c1">// Get the dimensions defined in the xml-tree
</span>    <span class="n">xml_comp_t</span>  <span class="n">coneDim</span> <span class="p">(</span> <span class="n">x_det</span><span class="p">.</span><span class="n">child</span><span class="p">(</span> <span class="n">_U</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
    <span class="c1">// Create the cone
</span>    <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Cone</span> <span class="n">cone</span><span class="p">(</span> <span class="n">coneDim</span><span class="p">.</span><span class="n">dz</span><span class="p">(),</span> <span class="n">coneDim</span><span class="p">.</span><span class="n">rmin1</span><span class="p">(),</span> <span class="n">coneDim</span><span class="p">.</span><span class="n">rmax1</span><span class="p">(),</span> <span class="n">coneDim</span><span class="p">.</span><span class="n">rmin2</span><span class="p">(),</span> <span class="n">coneDim</span><span class="p">.</span><span class="n">rmax2</span><span class="p">());</span>
    <span class="c1">// Create the volume corresponding to the cone
</span>    <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Volume</span> <span class="n">coneVol</span><span class="p">(</span> <span class="n">x_det</span><span class="p">.</span><span class="n">nameStr</span><span class="p">()</span><span class="o">+</span> <span class="s">"_SimpleCone"</span><span class="p">,</span> <span class="n">cone</span><span class="p">,</span> <span class="n">lcdd</span><span class="p">.</span><span class="n">material</span><span class="p">(</span><span class="n">coneDim</span><span class="p">.</span><span class="n">materialStr</span><span class="p">())</span> <span class="p">);</span>
    <span class="c1">// Create the placed volume
</span>    <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">PlacedVolume</span> <span class="n">conePhys</span><span class="p">;</span>
    <span class="c1">// And place it in the world
</span>    <span class="n">conePhys</span> <span class="o">=</span> <span class="n">experimentalHall</span><span class="p">.</span><span class="n">placeVolume</span><span class="p">(</span> <span class="n">coneVol</span><span class="p">,</span> <span class="c1">// the volume to be placed
</span>                                              <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Transform3D</span><span class="p">(</span><span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">RotationZ</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="c1">// any rotation to be done
</span>                                              <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Position</span> <span class="n">trans</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">));</span> <span class="c1">// the position where to place it
</span>    <span class="c1">// connect placed volume and physical volume
</span>    <span class="n">coneDet</span><span class="p">.</span><span class="n">setPlacement</span><span class="p">(</span> <span class="n">conePhys</span> <span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace detector
</span><span class="n">DECLARE_DETELEMENT</span><span class="p">(</span><span class="n">Example</span><span class="p">,</span> <span class="n">detector</span><span class="o">::</span><span class="n">createElement</span><span class="p">)</span> <span class="c1">// factory method
</span></code></pre>
</div>

<p>Again, the type <code class="highlighter-rouge">Example</code> in the xml-description corresponds to the name we put in the <code class="highlighter-rouge">DECLARE_DETELEMENT</code> macro, this creates the link between the factory method and the xml-description.</p>

<h2 id="sensitive-detectors">Sensitive Detectors</h2>

<p>The above example works, but it does not yet create any sensitive detectors that are needed by Geant4 to calculate and create energy deposits. While in GDML you have to define your sensitive detectors yourself, DD4hep has a mechanism of doing some of this for you.</p>

<p>Attaching the sensitive volume to the detector consists of:</p>

<ul>
  <li>Writing a sensitive detector that processes the hits and telling DD4hep to use it for a given detector</li>
  <li>Creating the readout structure (to uniquely identify the parts of the detector where the deposits are made).</li>
</ul>

<p>Both of them involve changes in the XML description and in the factory method.</p>

<h3 id="using-an-existing-sensitive-detector-definition">Using an Existing Sensitive Detector Definition</h3>

<p>The <strong>type</strong> of the sensitive detector corresponds to the name of a sensitive detector.
There are few implementations of the sensitive detectors in FCCSW:</p>

<ul>
  <li><code class="highlighter-rouge">SimpleTrackerSD</code></li>
  <li><code class="highlighter-rouge">SimpleCalorimeterSD</code></li>
  <li><code class="highlighter-rouge">AggregateCalorimeterSD</code></li>
</ul>

<p><code class="highlighter-rouge">SimpleTrackerSD</code> and <code class="highlighter-rouge">SimpleCalorimeterSD</code> create hits for each energy deposit. <code class="highlighter-rouge">AggregateCalorimeterSD</code> accumulates the energy deposits in cells and loops over the whole collection of hits, increasing the simulation time.</p>

<p>If you need to create your own custom SDs, see <a href="#user-defined-sensitive-detectors">User-defined Sensitive Detectors</a>.</p>

<ul>
  <li>In the XML description, the sensitive (active) module should be indicated for the corresponding detector:</li>
</ul>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;detector</span> <span class="na">id=</span><span class="s">"0"</span> <span class="err">...</span> <span class="na">sensitive=</span><span class="s">"true"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;sensitive</span> <span class="na">type=</span><span class="s">"SimpleTrackerSD"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/detector&gt;</span>
</code></pre>
</div>

<p>or for a sub-component, e.g. here for a <code class="highlighter-rouge">module_component</code>:</p>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;module_component</span> <span class="err">...</span> <span class="na">sensitive=</span><span class="s">"true"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<ul>
  <li>The factory method should then contain (corresponding to the first case):</li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">SensitiveDetector</span> <span class="n">sd</span> <span class="o">=</span> <span class="n">aSensDet</span><span class="p">;</span>
<span class="n">DD4hep</span><span class="o">::</span><span class="n">XML</span><span class="o">::</span><span class="n">Dimension</span> <span class="n">sdTyp</span> <span class="o">=</span> <span class="n">x_det</span><span class="p">.</span><span class="n">child</span><span class="p">(</span><span class="n">_U</span><span class="p">(</span><span class="n">sensitive</span><span class="p">));</span> <span class="c1">// retrieve the type
</span><span class="n">detVol</span><span class="p">.</span><span class="n">setSensitiveDetector</span><span class="p">(</span><span class="n">aSensDet</span><span class="p">);</span>                     <span class="c1">// set the type
</span><span class="k">if</span> <span class="p">(</span> <span class="n">x_det</span><span class="p">.</span><span class="n">isSensitive</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">sd</span><span class="p">.</span><span class="n">setType</span><span class="p">(</span><span class="n">sdTyp</span><span class="p">.</span><span class="n">typeStr</span><span class="p">());</span>                             <span class="c1">// set for the whole detector
</span><span class="p">}</span>
</code></pre>
</div>

<p>or (corresponding to the second case)</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">SensitiveDetector</span> <span class="n">aSensDet</span>
<span class="n">aSensDet</span><span class="p">.</span><span class="n">setType</span><span class="p">(</span><span class="s">"SimpleTrackerSD"</span><span class="p">);</span>       <span class="c1">// this could also be retrieved from xml like above
</span><span class="k">if</span> <span class="p">(</span><span class="n">xComp</span><span class="p">.</span><span class="n">isSensitive</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">modCompVol</span><span class="p">.</span><span class="n">setSensitiveDetector</span><span class="p">(</span><span class="n">aSensDet</span><span class="p">);</span> <span class="c1">// only set for certain components
</span><span class="p">}</span>
</code></pre>
</div>

<h3 id="readout-definition">Readout Definition</h3>

<p>In order to recognise where the energy was deposited, the sensitive volume has <strong>readout</strong> attached which allows to uniquely identify the volume element.</p>

<ul>
  <li>
    <p>Extending the xml-description:</p>

    <p>We need to add the <code class="highlighter-rouge">readout</code> tag to the detector description, which defines the way a unique ID is calculated for each sensitive detector. This ID is a 64 bit integer, where we can define which bits are used to identify what. E.g., if we had 4 sub-detectors, we would need 2 bits to uniquely identify each of them (2^2 = 4). Then if the sub-detector for which we want to add the sensitive detector had, e.g., 80 modules, we need 7 bits to uniquely identify those (6 bits correspond to 64 unique IDs, 7 to 128). Then if your modules had, yet again, sub components, you’d have to think about how many bits you need for those, etc. (<strong>Note</strong> that also if all 4 sub-detectors have 80 modules, we still would only need to have 7 bits for the modules, since we have the first 2 bits for sub-detector identification.)</p>

    <p>In addition to this unique identifier, the same mechanism of DD4hep allows to define a segmentation of your smallest component that allows you to track where a particle passed through your sensitive detector. For example we can define a grid with step sizes of 0.5 mm. DD4hep then needs also to be able to uniquely identify those within the component and the corresponding bits need to be reserved. In our example let’s keep half of the 64 bit integer for this grid, so 32 bits and half of each for x coordinate and y coordinate. Segmentation is described in more detail further.</p>

    <p>So in our example of 4 sub-detectors and our new detector having 80 modules, we would write this (leaving out all the boiler plate code shown above):</p>
  </li>
</ul>

<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;readouts&gt;</span>
  <span class="nt">&lt;readout</span> <span class="na">name=</span><span class="s">"ExampleReadout"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!-- add the grid and define the cell sizes --&gt;</span>
    <span class="nt">&lt;segmentation</span> <span class="na">type=</span><span class="s">"CartesianGridXY"</span> <span class="na">grid_size_x=</span><span class="s">"0.5*mm"</span> <span class="na">grid_size_y=</span><span class="s">"0.5*mm"</span><span class="nt">/&gt;</span>
    <span class="c">&lt;!-- define how the ID is calculated: 2 bits for the system ID (sub-detectors) --&gt;</span>
    <span class="c">&lt;!-- 7 bits for the modules and starting from bit 32, 16 bit for a signed (the "-") integer --&gt;</span>
    <span class="c">&lt;!-- for x and 16 bit signed integer for y. --&gt;</span>
    <span class="nt">&lt;id&gt;</span>system:2,module:7,x:32:-16,y:-16<span class="nt">&lt;/id&gt;</span>
  <span class="nt">&lt;/readout&gt;</span>
<span class="nt">&lt;/readouts&gt;</span>

<span class="nt">&lt;detectors&gt;</span>
  <span class="nt">&lt;detector</span> <span class="na">id=</span><span class="s">"0"</span> <span class="na">name=</span><span class="s">"Name"</span> <span class="na">type=</span><span class="s">"Example"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dimensions</span> <span class="na">rmin=</span><span class="s">"0"</span> <span class="na">rmax=</span><span class="s">"1*m"</span> <span class="na">dz=</span><span class="s">"1*m"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/detector&gt;</span>
<span class="nt">&lt;/detectors&gt;</span>
</code></pre>
</div>

<ul>
  <li>
    <p>Extending the factory method:</p>

    <p>In the factory method all we need to do is tell DD4hep what part a sensitive detector is and which part of the readout ID is foreseen for that part of the detector. Please note that segmentation is done automatically, hence it does not need any implementation in the factory method.</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// imagine the rest as above
</span><span class="n">conePhys</span> <span class="o">=</span> <span class="n">experimentalHall</span><span class="p">.</span><span class="n">placeVolume</span><span class="p">(</span> <span class="n">coneVol</span><span class="p">,</span> <span class="c1">// the volume to be placed
</span>                                          <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Transform3D</span><span class="p">(</span><span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">RotationZ</span><span class="p">(</span><span class="mf">0.</span><span class="p">),</span> <span class="c1">// any rotation to be done
</span>                                          <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Position</span> <span class="n">trans</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span> <span class="p">)</span> <span class="p">));</span> <span class="c1">// the position where to place it
</span>
<span class="c1">// Add the ID for our sub detector, using the ID number given in the xml
</span><span class="n">conePhys</span><span class="p">.</span><span class="n">addPhysVolID</span><span class="p">(</span> <span class="s">"system"</span><span class="p">,</span> <span class="n">x_det</span><span class="p">.</span><span class="n">id</span><span class="p">()</span> <span class="p">);</span>
<span class="c1">// connect placed volume and physical volume
</span><span class="n">coneDet</span><span class="p">.</span><span class="n">setPlacement</span><span class="p">(</span> <span class="n">conePhys</span> <span class="p">);</span>
<span class="c1">// Here you define your volume (skipping how to get dimensions, see above):
</span><span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Box</span> <span class="n">module</span><span class="p">(</span> <span class="p">...</span> <span class="p">);</span>
<span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Volume</span> <span class="n">moduleVol</span><span class="p">(</span> <span class="p">...</span> <span class="p">);</span>
<span class="c1">// Now we place the module:
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">iMod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">iMod</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">;</span> <span class="o">++</span><span class="n">iMod</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// skipping rotation and position here, but placing it somewhere:
</span>  <span class="k">auto</span> <span class="n">placedVol</span> <span class="o">=</span> <span class="n">conePhys</span><span class="p">.</span><span class="n">placeVolume</span><span class="p">(</span><span class="n">moduleVol</span><span class="p">,</span> <span class="p">...);</span>
  <span class="c1">// Tell DD4hep this is a sensitive detector
</span>  <span class="n">placedVol</span><span class="p">.</span><span class="n">setSensitiveDetector</span><span class="p">(</span><span class="n">sensDet</span><span class="p">);</span>
  <span class="c1">// Add the ID for the module and use the loop index as unique identification
</span>  <span class="n">placedVol</span><span class="p">.</span><span class="n">addPhysVolID</span><span class="p">(</span><span class="s">"module"</span><span class="p">,</span> <span class="n">iMod</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// rest as above
</span></code></pre>
</div>

<h3 id="user-defined-sensitive-detectors">User-defined Sensitive Detectors</h3>

<p>As mentioned above, you may want to define your own sensitive detector. For specifying the behaviour of the active elements (how and what should be saved in the hits collections), you need:</p>

<ol>
  <li>Implementation of G4VSensitiveDetector (in example below: <code class="highlighter-rouge">Detector/DetSensitive/src/SimpleCalorimeterSD.(h/cpp)</code>)</li>
  <li>Factory method (of SD) for DD4hep</li>
</ol>

<p>In order to use the common methods to store your information in the EDM output (at the end of simulation), we advise to use the DD4hep hits classes:
* <a href="https://svnsrv.desy.de/viewvc/aidasoft/DD4hep/trunk/DDG4/include/DDG4/Geant4Hits.h?revision=1822&amp;view=markup&amp;pathrev=2132"><em>DD4hep::Simulation::Geant4TrackerHit</em></a>
* <a href="https://svnsrv.desy.de/viewvc/aidasoft/DD4hep/trunk/DDG4/include/DDG4/Geant4Hits.h?revision=1822&amp;view=markup&amp;pathrev=2132"><em>DD4hep::Simulation::Geant4CalorimeterHit</em></a></p>

<p>If those classes are not sufficient, you’ll need to create your own hit class implementation and the corresponding tools to translate your hit collections to FCC-EDM.</p>

<h4 id="example-of-a-custom-sd">Example of a custom SD</h4>

<ul>
  <li>Implementation of G4VSensitiveDetector class, e.g. <code class="highlighter-rouge">det::SimpleCalorimeterSD</code>:
    <ul>
      <li><code class="highlighter-rouge">::Initialize(..)</code> - create the hit collection</li>
      <li><code class="highlighter-rouge">::ProcessHits(..)</code> - add entries to the hit collection with position, cellId, energy deposit, time, … Hit base class used in the collection is already implemented in DD4hep <code class="highlighter-rouge">DD4hep::Simulation::Geant4CalorimeterHit</code>.</li>
    </ul>

    <p>There is a method to retrieve the cell identification based on the DD4hep segmentation (<code class="highlighter-rouge">det::segmentation::cellID(DD4hep::Geometry::Segmentation, const G4Step&amp;)</code>).</p>
  </li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">det</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">SimpleCalorimeterSD</span> <span class="o">:</span> <span class="k">public</span> <span class="n">G4VSensitiveDetector</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">SimpleCalorimeterSD</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aDetectorName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aReadoutName</span><span class="p">,</span> <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">Segmentation</span> <span class="n">aSeg</span><span class="p">);</span>
  <span class="c1">/// Destructor
</span>  <span class="o">~</span><span class="n">SimpleCalorimeterSD</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">G4HCofThisEvent</span><span class="o">*</span> <span class="n">aHitsCollections</span><span class="p">)</span> <span class="n">final</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">ProcessHits</span><span class="p">(</span><span class="n">G4Step</span><span class="o">*</span> <span class="n">aStep</span><span class="p">,</span> <span class="n">G4TouchableHistory</span><span class="o">*</span><span class="p">)</span> <span class="n">final</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="c1">/// Collection of calorimeter hits
</span>  <span class="n">G4THitsCollection</span><span class="o">&lt;</span><span class="n">DD4hep</span><span class="o">::</span><span class="n">Simulation</span><span class="o">::</span><span class="n">Geant4CalorimeterHit</span><span class="o">&gt;*</span> <span class="n">calorimeterCollection</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<ul>
  <li>Factory method for DD4hep is created in <code class="highlighter-rouge">Detector/DetSensitive/src/SDWrapper.cpp</code>.
Any other sensitive detector may be added in the same way.</li>
</ul>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">DD4hep</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Simulation</span> <span class="p">{</span>
<span class="c1">// Factory method to create an instance of SimpleCalorimeterSD
</span><span class="k">static</span> <span class="n">G4VSensitiveDetector</span><span class="o">*</span> <span class="n">create_simple_calorimeter_sd</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">aDetectorName</span><span class="p">,</span>
                                                          <span class="n">DD4hep</span><span class="o">::</span><span class="n">Geometry</span><span class="o">::</span><span class="n">LCDD</span><span class="o">&amp;</span> <span class="n">aLcdd</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">readoutName</span> <span class="o">=</span> <span class="n">aLcdd</span><span class="p">.</span><span class="n">sensitiveDetector</span><span class="p">(</span><span class="n">aDetectorName</span><span class="p">).</span><span class="n">readout</span><span class="p">().</span><span class="n">name</span><span class="p">();</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">det</span><span class="o">::</span><span class="n">SimpleCalorimeterSD</span><span class="p">(</span><span class="n">aDetectorName</span><span class="p">,</span>
                                      <span class="n">readoutName</span><span class="p">,</span>
                                      <span class="n">aLcdd</span><span class="p">.</span><span class="n">sensitiveDetector</span><span class="p">(</span><span class="n">aDetectorName</span><span class="p">).</span><span class="n">readout</span><span class="p">().</span><span class="n">segmentation</span><span class="p">());</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="n">DECLARE_EXTERNAL_GEANT4SENSITIVEDETECTOR</span><span class="p">(</span><span class="n">SimpleCalorimeterSD</span><span class="p">,</span><span class="n">DD4hep</span><span class="o">::</span><span class="n">Simulation</span><span class="o">::</span><span class="n">create_simple_calorimeter_sd</span><span class="p">)</span>
</code></pre>
</div>

<p><strong>Note</strong> that the name we put in the <code class="highlighter-rouge">DECLARE_EXTERNAL_GEANT4SENSITIVEDETECTOR</code> macro corresponds to the type <code class="highlighter-rouge">SimpleCalorimeterSD</code> in the xml-description, this creates the link between the factory method and the xml-description.</p>

<h3 id="segmentation">Segmentation</h3>

<p>Possible grids (Cartesian 2D, Cartesian 3D, polar) can be found in <a href="https://svnsrv.desy.de/viewvc/aidasoft/DD4hep/trunk/DDSegmentation/src/?pathrev=2132">DDSegmentation</a>.</p>

<h4 id="cartesian-segmentation">Cartesian segmentation</h4>
<p>The centre of the Cartesian grid is in the centre of the detector.</p>

<p>The middle cell has the centre at <strong>x = 0</strong> and the boundaries are at <strong>(+/-)0.5*cellSize</strong>.
Note that for segmentation, the integers used for cell IDs need to be signed (indicated by ‘-‘ in the readout <code class="highlighter-rouge">&lt;id&gt;</code> tag in XML)</p>

<p>Figure below presents the cells and their identification for <code class="highlighter-rouge">cellSize = 1</code></p>

<pre>
   +-----------------------------+
   | -2  | -1  |  0  |  1  |  2  |
|-----|-----|-----|-----|-----|-----|---&gt; x
-3   -2    -1     0     1     2     3
</pre>

<p><strong>Caveat:</strong> due to the middle cell centred at <code class="highlighter-rouge">x = 0</code>, for some detectors the outermost cells may be of different size than the rest.</p>

<p>Let’s consider a detector of total width <code class="highlighter-rouge">detSize = 4</code> and the the cell width <code class="highlighter-rouge">cellSize = 1</code>. The segmentation that is usually introduced in Geant is to divide the detector into <code class="highlighter-rouge">detSize / cellSize = 4</code> cells which start from the detector boundary. It is depicted below:</p>

<pre>
 +-----------------------+
 |  0  |  1  |  2  |  3  |
-|-----|-----|-----|-----|---&gt; x
-2    -1     0     1     2
</pre>

<p>However, DD4hep segmentation of the volume is done automatically (for any detector shape), with a simple formula used to calculate the cell ID, without any knowledge of the detector size, boundaries etc.</p>

<p><code class="highlighter-rouge">int( floor( (position + 0.5 * cellSize ) / cellSize) )</code></p>

<p>The centre position of the volume becomes the centre of the middle cell. As a consequence, in the example below, the two outermost cells have the width of <code class="highlighter-rouge">0.5 * cellSize</code>.</p>

<pre>
 +-----------------------+
 |-2| -1  |  0  |  1  | 2|
-|-----|-----|-----|-----|---&gt; x
-2    -1     0     1     2
</pre>

<p><strong>Moreover</strong>, the total number of cells is <em>5</em> (even though ideally just 4 cells could be fitted inside detector volume).
So, instead of using <code class="highlighter-rouge">log_2(detSize / cellSize) = log_2(4) = 2</code> bits to decode the cellID, actually an additional bit needs to be used. Take this into consideration while defining the segmentation part of the readout structure.</p>

<h2 id="coordinate-conventions">Coordinate Conventions</h2>
<ul>
  <li>Position vector points to centre of volume</li>
  <li>Local coordinates start at the position vector</li>
  <li>Sizes are defined as the offset position vector
    <ul>
      <li>e.g. the size along x you give to the constructor of a cube is the half-width</li>
    </ul>
  </li>
</ul>

<h2 id="visualisation">Visualisation</h2>

<blockquote>
  <p>For the event visualisation in the detector please see <a href="../../Visualization/doc/DDEveInFCCSW.html">visualisation package documentation</a></p>
</blockquote>

<p>DD4hep comes with <code class="highlighter-rouge">geoDisplay</code> that can be used to display the detector geometry you implement. To use this display in the FCCSW context prepend the command with the <code class="highlighter-rouge">run</code> script in the FCCSW directory (after compilation).</p>

<p>You can also combine several description files (e.g. to check if components overlap, of if you want to use the <a href="#the-master-xmls">detector master files</a>):</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>./run geoDisplay -compact Detector/DetFCChhBaseline1/compact/FCChh_DectEmptyMaster.xml <span class="se">\</span>
                          Detector/DetFCChhHCalTile/compact/FCChh_HCalBarrel_TileCal.xml
</code></pre>
</div>

<p>N.b.: When running geoDisplay through a X-Session, by default OpenGL may not be used. If you see the warning:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>libGL error: No matching fbConfigs or visuals found
libGL error: failed to load driver: swrast
</code></pre>
</div>

<p>You can try to set the following environment variable to try and enable OpenGL:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="nb">export </span><span class="nv">LIBGL_ALWAYS_INDIRECT</span><span class="o">=</span>1
</code></pre>
</div>

<h2 id="fccsw-folder-structure">FCCSW folder structure</h2>

<p>The folder structure should look something like this (only including one baseline and one sub-detector), details may be found below:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>+ Detector              <span class="c"># the base directory</span>
|- DetInterface         <span class="c"># contains virtual interface classes</span>
|- DetComponents        <span class="c"># implementations of services / tools</span>
|- DetExtensions        <span class="c"># for reconstruction extensions</span>
|- DetSensitive         <span class="c"># custom sensitive detectors</span>
|+ DetCommon            <span class="c"># basic shapes / elements / materials</span>
 |- compact             <span class="c"># contains XMLs defining elements, materials, air volumes</span>
 |- src                 <span class="c"># factories for basic shapes</span>
|+ DetFCChhBaseline1    <span class="c"># the first FCC-hh baseline description</span>
 |- compact             <span class="c"># master XMLs defining dimensions and world volumes</span>
|+ DetFCChhHCalTile     <span class="c"># a sub-detector directory</span>
 |- compact             <span class="c"># contains XMLs defining the detector, optionally an XML for standalone tests</span>
 |- src                 <span class="c"># factories specific for this sub-detector</span>
</code></pre>
</div>

<p>The detector descriptions and geometry services / tools can be found in the <code class="highlighter-rouge">Detector</code> package. The FCCSW components that provide the geometry to the remaining packages can be found in:
- DetInterface (virtual interface classes)
- DetComponents (actual implementations of the services / tools)</p>

<p>Extensions of the DD4hep description are found in:
- DetExtensions (for reconstruction)
- DetSensitive (custom sensitive volumes)</p>

<h3 id="the-master-xmls">The master XMLs</h3>

<p>The descriptions are placed in sub-folders of the Detector package. We plan to have the possibility of having several baseline detectors for the different accelerators. For each such baseline we will have a sub-directory <code class="highlighter-rouge">"DetFCC" + Flavour + "Baseline" + X</code> where X will be an increasing index and <code class="highlighter-rouge">Flavour = ee, eh, hh</code>, selected to describe the accelerator the baseline is meant for (for example <code class="highlighter-rouge">DetFCChhBaseline1</code>). In each baseline description we expect to have a <code class="highlighter-rouge">compact</code> directory with:
- A dimensions XML that defines the sub-detector envelopes, e.g. <a href="../DetFCChhBaseline1/compact/FCChh_DectDimensions.xml">here</a>
- A master XML that includes the baseline sub-detectors, e.g. <a href="../DetFCChhBaseline1/compact/FCChh_DectMaster.xml">here</a>
- A master XML that does only include the dimensions (meant to be used with individual sub-detector XMLs) , e.g. <a href="../DetFCChhBaseline1/compact/FCChh_DectEmptyMaster.xml">here</a></p>

<p>More specifically, the latter allows to have the possibility to use the <code class="highlighter-rouge">GeoSvc</code> with a sub-set of sub-detectors using the official dimensions (e.g. <a href="../../Sim/SimG4Components/tests/options/geant_fullsim_hcal.py">here</a>).</p>

<h3 id="sub-detector-descriptions">Sub-detector descriptions</h3>

<p>Sub-detector directories follow the naming convention <code class="highlighter-rouge">"DetFCC" + Flavour + SubDetectorName + DetectorCharacteristic</code>, where <code class="highlighter-rouge">Flavour = ee, eh, hh</code>, <code class="highlighter-rouge">SubDetectorName = ECal, HCal, Tracker, Muon</code> and finally the <code class="highlighter-rouge">DetectorCharacteristic</code> specifies the concrete description (e.g. Parametric (for a description to be used with FastSim) or Tile (for an ATLAS-like TileCal)). Examples: <code class="highlighter-rouge">DetFCChhHCalTile</code> or <code class="highlighter-rouge">DetFCChhECalSimple</code>.</p>

<p>Sub-detector directories should in most cases have both <code class="highlighter-rouge">compact</code> and <code class="highlighter-rouge">src</code> directories. The description in compact <strong>should not</strong> have a world volume defined in order to be able to include it in a master xml. If a description for standalone tests (with dimensions deviating from the baseline) is needed, it may be placed alongside the detector description with a postfix <code class="highlighter-rouge">Standalone</code> (and this one should define the world volume). However, please note that for standalone tests that use the baseline dimensions something like this should rather be put in the corresponding options file:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">geoservice</span> <span class="o">=</span> <span class="n">GeoSvc</span><span class="p">(</span><span class="s">"GeoSvc"</span><span class="p">,</span> <span class="n">detectors</span><span class="o">=</span><span class="p">[</span><span class="s">'file:Detector/DetFCChhBaseline1/compact/FCChh_DectEmptyMaster.xml'</span><span class="p">,</span>
                                         <span class="s">'file:Detector/DetFCChhHCalTile/compact/FCChh_HCalBarrel_TileCal.xml'</span> <span class="p">]</span>
</code></pre>
</div>

<p>To facilitate this mix-and-match functionality, the sub-detectors should use the variables that describe the envelope volume which are defined in the master dimensions. For all sub-detectors variables <code class="highlighter-rouge">rmin</code>, <code class="highlighter-rouge">rmax</code> and <code class="highlighter-rouge">dz</code> are defined with the naming convention <code class="highlighter-rouge">DetectorPart + SubDetector + '_' + variable</code> where <code class="highlighter-rouge">DetectorPart</code> can be <code class="highlighter-rouge">Bar</code>, <code class="highlighter-rouge">EndCap</code> or <code class="highlighter-rouge">Fwd</code>, <code class="highlighter-rouge">SubDetector</code> can be <code class="highlighter-rouge">Tracker</code>, <code class="highlighter-rouge">ECal</code>, <code class="highlighter-rouge">HCal</code> or <code class="highlighter-rouge">Muon</code> and variable can be <code class="highlighter-rouge">rmin</code>, <code class="highlighter-rouge">rmax</code>, <code class="highlighter-rouge">dz</code> or <code class="highlighter-rouge">zOffset</code> (only for forward and end-cap detectors). Examples: <code class="highlighter-rouge">BarHCal_rmin</code> or <code class="highlighter-rouge">FwdHCal_zOffset</code>.</p>

<h3 id="common-descriptions">Common descriptions</h3>

<p>The final sub-directory <code class="highlighter-rouge">DetCommon</code> includes descriptions and macros that should be independently usable by all baselines / sub-detectors. This includes primitive shapes (cones, cylinders, boxes, etc.), material &amp; element descriptions. Additionally place-holders can be found that place air-filled cylinders using the dimensions defined in a master-dimension file. These are meant for debugging the dimensions file.</p>

<h2 id="material-budget-estimation">Material budget estimation</h2>

<p>We provide an example configuration and plotting script for estimating the material budget as a function of eta.</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>./run gaudirun.py Examples/options/material_scan.py
./run python Examples/scripts/material_plots.py
</code></pre>
</div>

<p>The configuration file <code class="highlighter-rouge">material_scan</code> allows to customize the binning of the material scan with <code class="highlighter-rouge">etaMax</code> and <code class="highlighter-rouge">etaBinning</code>. The scan is
performed from <code class="highlighter-rouge">-etaMax</code> to <code class="highlighter-rouge">+etaMax</code> with a step-size of <code class="highlighter-rouge">etaBinning</code>. The detector which is scanned is optained from
the <code class="highlighter-rouge">GeoSvc</code> and the corresponding detector description can be changed there as usual.</p>

<p>The output of the first command is the ROOT file <code class="highlighter-rouge">DD4hep_material_scan.root</code> which contains a <code class="highlighter-rouge">TTree</code> that has 6 branches:</p>

<ul>
  <li><code class="highlighter-rouge">eta</code>: The pseudorapidity along which the ray was cast from <code class="highlighter-rouge">(0, 0, 0)</code></li>
  <li><code class="highlighter-rouge">nMaterials</code>: The number of materials found by the ray-cast along the eta direction</li>
  <li><code class="highlighter-rouge">nX0</code>: The number of radiation lenghts <code class="highlighter-rouge">X0</code> for each material in this eta bin</li>
  <li><code class="highlighter-rouge">nLambda</code>: The number of nuclear interaction lengths <code class="highlighter-rouge">lambda</code> for each material in this eta bin</li>
  <li><code class="highlighter-rouge">matDepth</code>: The depth in <em>mm</em> for each material in this eta bin</li>
  <li><code class="highlighter-rouge">material</code>: The names of all materials in this eta bin (as defined in DD4hep)</li>
</ul>

<p>The plotting script outputs three plots as <code class="highlighter-rouge">pdf</code>, which contain the number of interaction lenghts, radiation lengths and
the material thickness, stacked according to the material name. Additionally, the plots are created for <code class="highlighter-rouge">|eta|</code> and <code class="highlighter-rouge">eta</code>.
The script sums up all materials that have the same name in the eta bin and discards any air that is encountered.</p>

<h2 id="troubleshooting">Troubleshooting</h2>

<ul>
  <li>Overlapping volumes may lead to some hard-to-detect errors. If a daughter volume is completely outside the parent volume, an error is reported during the conversion to Geant4 geometry description (<code class="highlighter-rouge">PANIC! - Overlapping daughter with mother volume.</code>). But sometimes overlaps errors are silent, yet result in sensitive detectors not registering any hits. The test suite therefore includes a check on overlaps in <code class="highlighter-rouge">FCChh_DectMaster.xml</code>, which should be fixed. It is located under ` Test/TestGeometry/tests/options/geant_overlap_test_fcchh.py<code class="highlighter-rouge">, if it is needed to be run manually. A second test is provided by the ROOT geometry package. It can be run via the </code>checkOverlaps.py<code class="highlighter-rouge"> script from DD4hep. With the command line option </code>-o s` it uses sampling to check for overlaps, but ignores extrusions of daughter volumes. Without this option, it is vice-versa, so it is recommended to run it in both modes. Note that the sampling does not work correctly if several xml files are used for the detector description. It is best to add your detector to the master xml file.</li>
  <li>It is an error to declare a volume as well as one of its daughters sensitive. This is reported somewhat confusingly as <code class="highlighter-rouge">populate: Severe error: Duplicated Volume entry: 1A [THIS SHOULD NEVER HAPPEN]</code> but is in fact an issue with the sensitive detector.</li>
</ul>


      </div>
      <div class="col-md-2">    <ul class="list-group">
        <li class="list-group-header">
            <h4>External links</h4>
        </li>
        
            <li class="list-group-item">
                <a href='http://cern.ch/simba3/SelfSubscription.aspx?groupName=fcc-experiments-sw-dev'>FCCSW Mailing list</a>
            </li>
        
            <li class="list-group-item">
                <a href='http://fccsw.web.cern.ch/fccsw/tutorials/'>FCCSW Tutorials</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/fccsw/issues'>FCCSW Issue Tracker</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/'>FCCSW on GitHub</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://phsft-jenkins.cern.ch/view/FCC/'>FCCSW Jenkins</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/FCCSW/blob/master/doc/CppCodingStyleGuidelines.md'>FCCSW C++ Style Guide</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/FCCSW/blob/master/doc/GeneralCppGuidelines.md'>General C++ Guidelines</a>
            </li>
        
    </ul>
</div>
    </div>
    <script src="http://fccsw.web.cern.ch/fccsw/node_modules/jquery/dist/jquery.min.js" type="text/javascript"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/bootstrap-sass/assets/javascripts/bootstrap.min.js" type="text/javascript"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/requirejs/require.js" type="text/javascript"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/simple-jekyll-search/dest/simple-jekyll-search.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/javascript">
      SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('searchresults'),
        json: 'http://fccsw.web.cern.ch/fccsw/search.json',
        searchResultTemplate: '<li class="list-group-item"><a href="{url}" title="{desc}">{title}</a></li>',
        noResultsText: '<li class="list-group-item">No results found</li>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });
      $("#search-input").keypress(function() {
            $("#resultswrap").collapse('show');
      });
      $("#search-input").keyup(function() {
            if ($(this).val() == "") {
                $("#resultswrap").collapse('hide');
            }
      });
      $("table").each(function(index) {
        $(this).addClass("table");
      });
    </script>


  </body>
</html>
