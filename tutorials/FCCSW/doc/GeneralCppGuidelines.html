<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>General Cpp Guidelines</title>
  <meta name="description" content="Main page for documentation and resources.">

  <link rel="stylesheet" href="http://fccsw.web.cern.ch/fccsw/css/main.css">
  <link rel="canonical" href="http://fccsw.web.cern.ch/fccsw/tutorials/FCCSW/doc/GeneralCppGuidelines.html">
  <link rel="alternate" type="application/rss+xml" title="FCCSW" href="http://fccsw.web.cern.ch/fccsw/feed.xml">
</head>


  <body>

    
<header>
   <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://fccsw.web.cern.ch/fccsw/index.html">FCCSW</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li ><a href="http://fccsw.web.cern.ch/fccsw/index.html">Home</a></li>
            <li  class="active" ><a href="http://fccsw.web.cern.ch/fccsw/tutorials">Tutorials</a></li>
            <li><a>Latest Releases:</a></li>
            
            
              
              <li >
                <a href="http://fccsw.web.cern.ch/fccsw/2017/05/15/version081.html">FCCSW v0.8.1</a>
              </li>
              
            
              
              <li >
                <a href="http://fccsw.web.cern.ch/fccsw/2017/03/29/version08.html">FCCSW v0.8</a>
              </li>
              
            
            <li ><a href="http://fccsw.web.cern.ch/fccsw/snapshot.html">Snapshot</a></li>
          </ul>
          <form class="navbar-form navbar-right">
            <div class="input-group">
            <span class="input-group-addon" id="basic-addon1"><span class="glyphicon glyphicon-search" aria-hidden="true"></span></span>
            <input type="text" class="form-control" id="search-input" placeholder="Search" aria-describedby="basic-addon1">
            </div>
          </form>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

</header>
<div class="container">
  <div class="collapse panel panel-default" id="resultswrap">
      <div class="panel-heading">Search Results <button type="button" class="close" aria-label="Close"><span aria-hidden="true" onclick="$('#resultswrap').collapse('hide');">&times;</span></button></div>
      <ul id="searchresults" class="list-group">
      </ul>
  </div>
</div>

    
    
    <div class="container">
      <div class="col-md-10">
        <h1 id="fccsw-guidelines-for-c-code">FCCSW Guidelines for C++ Code</h1>

<p>The first sentences of each section is an executive summary of the section.</p>

<h2 id="goal">Goal</h2>

<p>Some common sense guidelines on how to write code that is easier to maintain. Please keep in mind that such a document can never be complete but only a starting point.</p>

<h2 id="contents">Contents</h2>

<ul>
  <li><a href="#repository-rules">Repository Rules</a></li>
  <li><a href="#general-remarks">General Remarks</a></li>
  <li><a href="#scope-and-initialisation">Scope and Initialisation</a></li>
  <li><a href="#namespaces">Namespaces</a></li>
  <li><a href="#poiners-and-references">Pointers and References</a></li>
  <li><a href="#constness">Constness</a></li>
  <li><a href="#lifetime">Lifetime</a></li>
  <li><a href="#best-practices-in-parallelism">Best Practices in Parallelism</a></li>
  <li><a href="#auto">Useful C++11 Features</a></li>
  <li><a href="#other-things-to-avoid">Other Things to Avoid</a></li>
  <li><a href="#further-reading">Further Reading</a></li>
</ul>

<h2 id="repository-rules">Repository Rules</h2>

<p>As mentioned in the README, the contributions to the code are reviewed in pull-requests.</p>

<h3 id="code-in-the-master-branch">Code in the master-branch:</h3>

<p>Code that is committed and pushed to the master branch has to compile without warnings.</p>

<h3 id="code-in-topic--development-branches">Code in topic / development branches:</h3>

<p>Code pushed in dedicated topic branches that are used by a sub-group has to compile.</p>

<h2 id="general-remarks">General Remarks</h2>

<ul>
  <li>Try to write code that is easy to understand
    <ul>
      <li>Use inheritance only where it is needed
        <ul>
          <li>Avoid complicated inheritance diagrams</li>
          <li>Avoid multiple inheritance</li>
          <li>Avoid friend classes</li>
        </ul>
      </li>
      <li>Use templates with care</li>
      <li>Consider whether aggregation or composition is needed</li>
      <li>If something can be written in one line instead of four does not mean it is better</li>
      <li>Avoid multiply branching code (nested <code class="highlighter-rouge">if</code> or loop constructs)</li>
    </ul>
  </li>
  <li>Document your code
    <ul>
      <li>Document your interfaces (Doxygen compatible)
        <ul>
          <li>Make clear what are the inputs and what are the outputs</li>
        </ul>
      </li>
      <li>Document the purpose of your class</li>
      <li>If multiple known solutions exist, mention why you chose the one you did</li>
    </ul>
  </li>
  <li>Make things explicit
    <ul>
      <li>Read about constness below</li>
      <li>Try to choose function names that already describe what it does</li>
    </ul>
  </li>
</ul>

<h2 id="scope-and-initialisation">Scope and Initialisation</h2>

<p>Place variables / objects in the narrowest scope possible and initialise variables where you declare them.</p>

<p>For class members use the member initialiser list instead of constructor-body to initialise.</p>

<p><strong>Examples</strong></p>

<p>Initialise where you declare:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// C++11
</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>
</code></pre>
</div>

<p>Member initialiser list:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">m_bar</span><span class="p">(</span><span class="n">bar</span><span class="p">),</span>
  <span class="n">m_foo</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Variables needed for loops should be declared within the statements to confine to scope:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Caveat: Objects needed in the loop should not be created on each iteration:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Foo</span> <span class="n">f</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">f</span><span class="p">.</span><span class="n">doSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="namespaces">Namespaces</h2>

<p>All entities are contained in a namespace. The only exception are classes that are plugins / components (i.e. classes that are not used by other code).</p>

<p><em>Warning</em>: Do not include header files within the namespace region but before!</p>

<h3 id="non-member-functions-and-namespaces">Non-member Functions and Namespaces</h3>

<p>If non-member functions are associated to a specific class they belong in the same namespace as the class.</p>

<p>Non-member functions that are not associated to specific classes are grouped in namespaces by functionality.</p>

<h3 id="avoid-using-using-namespace">Avoid Using <code class="highlighter-rouge">using namespace</code></h3>

<p>Never write <code class="highlighter-rouge">using namespace</code>.</p>

<p>If the statement is used in a header file, the statement holds in any code that includes that header file. While the effect may be less detrimental in implementation files, consider that it hides information from future maintainers.</p>

<p>Similar to python’s importing rules, only use the statement for single entities from a namespace so it is clear where it is defined and to avoid name hiding:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">mathpackage</span><span class="o">::</span><span class="n">sqrt</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">printSqrt</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="pointers-and-references">Pointers and References</h2>

<p>The code should not contain <code class="highlighter-rouge">new</code> outside of braces. Avoid raw-pointers where possible.</p>

<p>Raw C++ pointers should be avoided. Only use them when you are certain that you have to. Consider using <code class="highlighter-rouge">std::unique_ptr</code>, <code class="highlighter-rouge">std::shared_ptr</code> and references instead.</p>

<p>Pass by const reference instead of const pointer.</p>

<p>Avoid dangling handles (references or pointers) by avoiding to return references or pointers.</p>

<h3 id="when-pointers">When Pointers</h3>

<p>Special cases may arise where pointers are needed (e.g. interface to external packages). In that case <strong>document!</strong> Please document <em>why</em> you use a pointer, <em>who</em> is responsible for the pointer’s deletion, <em>when</em> the pointer is deleted.</p>

<p><em>If you <strong>really</strong> need to</em> declare a pointer without instantiating the corresponding object, use <code class="highlighter-rouge">nullptr</code>. Avoid null-pointers wherever possible.</p>

<p><strong>Examples</strong></p>

<p>Unique pointers: They hold sole ownership over the contained object. It is not possible to have two <code class="highlighter-rouge">unique_ptr</code> managing the same object.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">myPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">);</span>
  <span class="c1">// Smart pointers allow normal pointer semantics:
</span>  <span class="n">myPtr</span><span class="o">-&gt;</span><span class="n">doSomething</span><span class="p">();</span>  <span class="c1">// Calls the member function of Foo
</span>  <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">myPtr</span><span class="p">);</span>             <span class="c1">// Passes a reference to Foo (or value, depending on the function argument)
</span><span class="p">}</span> <span class="c1">// myPtr goes out of scope and the instance of Foo is deleted automatically
</span></code></pre>
</div>

<p>Shared pointers: Shared ownership of the object across several instances of the pointers. The object is deleted when the last <code class="highlighter-rouge">shared_ptr</code> managing it is destroyed or the last managing <code class="highlighter-rouge">shared_ptr</code> is assigned another object to hold.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="p">{</span>
  <span class="c1">// Let's assume Bar is derived from Foo:
</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">myPtr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">{</span>
    <span class="c1">// This myPtr2 points to the same instance of Bar:
</span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">myPtr2</span> <span class="o">=</span> <span class="n">myPtr1</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// myPtr2 goes out of scope, but myPtr1 stays in scope, the instance still exists
</span><span class="p">}</span> <span class="c1">// Here, the instance of Bar is deleted: The last pointer, myPtr1, goes out of scope
</span></code></pre>
</div>

<h2 id="constness">Constness</h2>
<p>Use <code class="highlighter-rouge">const</code> wherever you can.</p>

<p>If <code class="highlighter-rouge">const</code> is used correctly, the compiler helps to identify potential problems.</p>

<p>Functions without side-effects are preferable and should be marked as such. Declare member-functions that do not change the state of the object as <code class="highlighter-rouge">const</code>.</p>

<p>If your function is only “an observer” of an argument, make it explicit. This way you get compiler errors when a function unexpectedly does change the object’s state (if the above rule is followed).</p>

<p>Getter functions should return const values or references. <em>Note</em> that when returning a reference and you cannot guarantee the object’s validity after the function call, you risk a dangling reference.</p>

<p><strong>Example</strong></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Omitting ctor and dtor
</span>
  <span class="c1">// The getter does not change the state of Foo
</span>  <span class="k">const</span> <span class="n">Vector3</span> <span class="n">position</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_position</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This function does not change the state of Foo or the argument
</span>  <span class="k">const</span> <span class="n">Vector3</span> <span class="n">offset</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3</span><span class="o">&amp;</span> <span class="n">otherPosition</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">m_position</span> <span class="o">-</span> <span class="n">otherPosition</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This set-function does change the state of Foo not of the argument
</span>  <span class="kt">void</span> <span class="n">setPosition</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector3</span><span class="o">&amp;</span> <span class="n">newPosition</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_position</span> <span class="o">=</span> <span class="n">newPosition</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// This function does change the argument but not Foo
</span>  <span class="kt">void</span> <span class="n">addPositionTo</span><span class="p">(</span><span class="n">Vector3</span><span class="o">&amp;</span> <span class="n">otherPosition</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">otherPosition</span> <span class="o">+=</span> <span class="n">m_position</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
 <span class="n">Vector3</span> <span class="n">m_position</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<h2 id="lifetime">Lifetime</h2>

<p>Always consider what the lifetime of an entity is and restrict it to the shortest period that makes sense.</p>

<p>Sometimes it is not inherently clear what the lifetime of an object in memory is. While names only exist in the scope in which they are defined, the objects they refer to can exist longer:
- Objects created with <code class="highlighter-rouge">new</code> live until they are destroyed using <code class="highlighter-rouge">delete</code>.
- The lifetime of static objects is from the time they are defined the first time until the program exits</p>

<p>If objects exist longer than their name, the corresponding memory is “leaked” (i.e. practically, it becomes unusable). This directly translates into performance issues. Therefore
- Use smart-pointers instead of raw pointers
- Avoid static objects</p>

<h2 id="best-practices-in-parallelism">Best Practices in Parallelism</h2>

<h3 id="statelessness">Statelessness</h3>

<p>Write stateless functions and classes wherever possible.</p>

<p>Practically speaking, stateless functions are functions that always produce the same result given the same inputs. Examples are implementations of mathematical functions or pure functions.  Note that statelessness is a stricter concept than constness: A const function may still depend on a member of the object (i.e. the state of the object) that can be altered between calls.</p>

<p>Stateless objects do not have any member fields that can be altered. I.e. they only have compile-time constants as members. Note that being stateless is a stricter requirement than immutable: An immutable object has only <code class="highlighter-rouge">const</code> members but they may depend on the initialisation.</p>

<p>The benefit in terms of parallelism is that the function / object can be safely used in different threads and will still produce the desired result, as there is no shared information / state that can be altered between the threads.</p>

<p>See also <a href="#const-expressions">const-expressions</a> below.</p>

<h3 id="re-entrancy">Re-entrancy</h3>

<p>If a function cannot be stateless, the state should be local.</p>

<p>Re-entrant functions can be interrupted at any point and re-entered without altering results. They may depend on the state of the object but the state cannot change between calls (e.g. const members of an object). Especially the use of non-const static or global data breaks re-entrancy. For a function to be re-entrant, it can only call re-entrant code.</p>

<h2 id="useful-c11-features">Useful C++11 Features</h2>

<h3 id="auto">Auto</h3>

<p>Where the type of an object can be inferred by the compiler, <code class="highlighter-rouge">auto</code> can be used.</p>

<p>It can be useful to decouple from specific implementations of data-structures. To take constness into account, use <code class="highlighter-rouge">const auto</code>. Similarly you can get a reference with <code class="highlighter-rouge">const auto&amp;</code>.</p>

<p><strong>Examples</strong></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="c1">// An iterator:
</span><span class="k">auto</span> <span class="n">vectorIterator</span> <span class="o">=</span> <span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="c1">// A const iterator:
</span><span class="k">auto</span> <span class="n">vectorConstIterator</span> <span class="o">=</span> <span class="n">myVector</span><span class="p">.</span><span class="n">cbegin</span><span class="p">();</span>
<span class="c1">// A reference to the collection of tracks:
</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">trackCollection</span> <span class="o">=</span> <span class="n">getTracks</span><span class="p">();</span>
</code></pre>
</div>

<h3 id="for-loops">For Loops</h3>

<p>Use the C++11 for-loop syntax to avoid common mistakes.</p>

<p>In combination with <code class="highlighter-rouge">auto</code>, iterators are even easier to use in C++ and should be preferred over index loops when looping over container contents. C++11 also defines a syntax for a loop that iterates automatically over each object in a container.</p>

<p><strong>Examples</strong></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myVec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
<span class="c1">// Iterate over all contents
</span><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cntr</span> <span class="o">:</span> <span class="n">myVec</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cntr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Using auto and iterators in loops
</span><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myVec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">myVec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="const-expressions">Const-Expressions</h3>
<p>Use <code class="highlighter-rouge">constexpr</code> if an expression can be calculated at compile time.</p>

<p>Const expressions are evaluated at compile time (i.e. no computation during run time). You can declare functions, variables and even constructors as <code class="highlighter-rouge">constexpr</code>.</p>

<p><strong>Example</strong></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">addTwo</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">arg</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">a</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">addTwo</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">addTwo</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</code></pre>
</div>

<h3 id="move-semantics">Move semantics</h3>
<p>A destructive(!) variant of copy which can optimise performance.</p>

<p>Sometimes it makes sense not to duplicate the data contained in an object but just to adjust pointers instead. This makes only sense in certain cases:
- You want to swap objects
- The object that is moved somewhere else cannot be used afterwards</p>

<p>Example use case: Storing objects instead of pointers in <code class="highlighter-rouge">std::vector</code> can be made efficient when implementing the move constructor:</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="other-things-to-avoid">Other Things to Avoid</h2>

<ul>
  <li>Do not write singletons</li>
  <li>Do not define global variables, any entity in the global namespace</li>
  <li>Never have non-const static functions or member data</li>
</ul>

<h3 id="avoid-c-syntax">Avoid C syntax</h3>

<p>While most C-code compiles as C++, it is strongly discouraged.</p>

<p>An incomplete list:
- Use const-expressions instead of macros (see <a href="#const-expressions">above</a> for details)
- Use enums or <code class="highlighter-rouge">static const</code> variables instead of constants
- Forget about <code class="highlighter-rouge">malloc</code>, etc.
- Prefer C++ style casts: <code class="highlighter-rouge">static_cast&lt;int&gt;(variable)</code> instead of <code class="highlighter-rouge">(int) variable</code></p>

<h2 id="further-reading">Further Reading</h2>

<p>There are many good books and open material about best practices in C++. An incomplete list:
- Scott Meyers, <em>Effective C++</em> and <em>More Effective C++</em>
- to be extended…</p>

      </div>
      <div class="col-md-2">    <ul class="list-group">
        <li class="list-group-header">
            <h4>External links</h4>
        </li>
        
            <li class="list-group-item">
                <a href='http://cern.ch/simba3/SelfSubscription.aspx?groupName=fcc-experiments-sw-dev'>FCCSW Mailing list</a>
            </li>
        
            <li class="list-group-item">
                <a href='http://fccsw.web.cern.ch/fccsw/tutorials/'>FCCSW Tutorials</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/fccsw/issues'>FCCSW Issue Tracker</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/'>FCCSW on GitHub</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://phsft-jenkins.cern.ch/view/FCC/'>FCCSW Jenkins</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/FCCSW/blob/master/doc/CppCodingStyleGuidelines.md'>FCCSW C++ Style Guide</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/FCCSW/blob/master/doc/GeneralCppGuidelines.md'>General C++ Guidelines</a>
            </li>
        
    </ul>
</div>
    </div>
    <script src="http://fccsw.web.cern.ch/fccsw/node_modules/jquery/dist/jquery.min.js" type="text/javascript"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/bootstrap-sass/assets/javascripts/bootstrap.min.js" type="text/javascript"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/requirejs/require.js" type="text/javascript"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/simple-jekyll-search/dest/simple-jekyll-search.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/javascript">
      SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('searchresults'),
        json: 'http://fccsw.web.cern.ch/fccsw/search.json',
        searchResultTemplate: '<li class="list-group-item"><a href="{url}" title="{desc}">{title}</a></li>',
        noResultsText: '<li class="list-group-item">No results found</li>',
        limit: 10,
        fuzzy: false,
        exclude: ['Welcome']
      });
      $("#search-input").keypress(function() {
            $("#resultswrap").collapse('show');
      });
      $("#search-input").keyup(function() {
            if ($(this).val() == "") {
                $("#resultswrap").collapse('hide');
            }
      });
      $("table").each(function(index) {
        $(this).addClass("table");
      });
    </script>


  </body>
</html>
