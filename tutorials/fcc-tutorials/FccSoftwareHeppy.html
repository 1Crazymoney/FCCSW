<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>FCCSW</title>
  <meta name="description" content="Main page for documentation and resources.">

  <link rel="stylesheet" href="http://fccsw.web.cern.ch/fccsw/css/main.css">
  <link rel="canonical" href="http://fccsw.web.cern.ch/fccsw/tutorials/fcc-tutorials/FccSoftwareHeppy.html">
  <link rel="alternate" type="application/rss+xml" title="FCCSW" href="http://fccsw.web.cern.ch/fccsw/feed.xml">
</head>


  <body>

    
<header>
   <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="http://fccsw.web.cern.ch/fccsw/index.html">FCCSW</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li ><a href="http://fccsw.web.cern.ch/fccsw/index.html">Home</a></li>
            <li  class="active" ><a href="http://fccsw.web.cern.ch/fccsw/tutorials">Tutorials</a></li>
            <li><a>Latest Releases:</a></li>
            
            
              
            
              
              <li >
                <a href="http://fccsw.web.cern.ch/fccsw/2016/11/01/version08pre.html">FCCSW v0.8pre</a>
              </li>
              
            
              
              <li >
                <a href="http://fccsw.web.cern.ch/fccsw/2016/08/16/version07.html">FCCSW v0.7</a>
              </li>
              
            
            <li ><a href="http://fccsw.web.cern.ch/fccsw/snapshot.html">Snapshot</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

</header>

    
    
    <div class="container">
      <div class="col-md-10">
        <h1 id="heppy--a-mini-framework-for-hep-event-processing-in-python"><a href=""></a> Heppy : a mini framework for HEP event processing in python</h1>

<p>Contents:</p>

<ul>
  <li><a href="#heppy-a-mini-framework-for-hep-e">Heppy : a mini framework for HEP event processing in
python</a>
    <ul>
      <li><a href="#prerequisites">Prerequisites</a></li>
      <li><a href="#reference-guide">Reference guide</a></li>
      <li><a href="#a-short-description-of-the-analy">A short description of the analysis
system</a>
        <ul>
          <li><a href="#the-ntuplizer">The ntuplizer</a></li>
        </ul>
      </li>
      <li><a href="#installation">Installation</a></li>
      <li><a href="#generating-an-edm-root-file-with">Generating an EDM root file with
pythia</a></li>
      <li><a href="#exercises">Exercises</a>
        <ul>
          <li><a href="#1-understanding-the-configuratio">1- Understanding the configuration
file</a></li>
          <li><a href="#2-finding-existing-analysis-code">2- Finding existing analysis
code</a></li>
          <li><a href="#3-running-interactively-on-one-c">3- Running interactively on one
component</a></li>
          <li><a href="#4-multiprocessing-on-a-single-ma">4- Multiprocessing on a single
machine</a></li>
          <li><a href="#5-using-papas-the-particle-flow">5- Using PAPAS, the particle flow
simulation</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="prerequisites"><a href=""></a> Prerequisites</h2>

<p><strong>You must follow <a href="./FccSoftwareEDM">FccSoftwareEDM</a>{.twikiLink} first</strong>
.</p>

<p><strong>You should be familiar with python to follow this tutorial</strong> .</p>

<p>I strongly advise to carefully follow <a href="http://docs.python.org/tutorial/index.html">the python
tutorial</a> if not yet done.
It will take you a few hours now, but will gain you many days in the
future.</p>

<p>Why python? In short:</p>

<ul>
  <li>fast learning curve: python is the most easy-to-learn language</li>
  <li>high productivity: coding in python is about 10 times faster than in
C++</li>
  <li>high flexibility: code can be easily reused, refactored, extended.</li>
  <li>dynamic typing (similar to C++ template features, without the pain
in the neck): if you do an analysis for e.g. the muon channel, it is
going to work for the electron channel with only minor modifications
related to lepton identification. If your analysis reads a certain
kind of particle-like objects, it will probably work on other kinds
of particle-like objects.</li>
  <li>very large and easy-to-use standard library</li>
</ul>

<h2 id="reference-guide"><a href=""></a> Reference guide</h2>

<ul>
  <li><a href="http://fcc-support-heppy.web.cern.ch/fcc-support-heppy/">Reference
guide</a> :
documentation automatically generated with pydoc</li>
</ul>

<h2 id="a-short-description-of-the-analysis-system"><a href=""></a> A short description of the analysis system</h2>

<h3 id="the-ntuplizer"><a href=""></a> The ntuplizer</h3>

<p>This goal of the ntuplizer system is to produce a flat tree for each of
the datasets (also called “components”) used in the analysis. Any
operation requiring a user-written loop on the events can be done while
producing the flat tree, so that the resulting trees can be used with
simple TTree.Draw or TTree.Project commands.</p>

<p>For example, the ntuplizer makes it possible to:</p>

<ul>
  <li>read events from an albers root file produced using the FCC
software framework.</li>
  <li>create python physics objects to hold the C++ objects from the
albers root file. These objects have the exact same interface as the
C++ objects, and can be extended with more information. For example,
you could write your own muon ID function for your python Muon
object, or add attributes to your python Muons along the processing
flow, like the 4-momentum of the closest jet or the closest
generated muon.</li>
  <li>create new python objects, e.g. a Z object containing two leptons.</li>
  <li>compute event-by-event weights</li>
  <li>select a trigger path, and match to the corresponding trigger
objects</li>
  <li>define and write simple flat trees</li>
</ul>

<p>It is up to you to define what you want to do, possibly re-using
existing code from other analyses or writing your own.</p>

<p>An analysis typically consists in several tenth of samples, or
“components”: data samples, standard model backgrounds, signal. The
ntuplizer is built in such a way that it takes one command to either:</p>

<ul>
  <li>run interactively on a single component</li>
  <li>run several processes in parallel on your multiprocessor machine</li>
  <li>run hundreds of processes as separate jobs on LSF, the CERN
batch cluster.</li>
</ul>

<p>If you decide to run several processes, you can split a single component
in as many chunks as input ROOT files for this component. For example,
you could run in parallel:</p>

<ul>
  <li>6 chunks from the DYJet component, using 6 processors of your local
machine, assuming you have more than 6 input DYJet ROOT files.</li>
  <li>200 chunks from the DYJet component, 300 from your 5 data components
altogether, and 300 jobs from all the remaing components (e.g.
di-boson, TTJets, …) on LSF.</li>
</ul>

<p>The ntuplizer is based on python, pyroot, and the albers event data
model (EDM). It could have been written as a simple python macro based
on ROOT and albers. Instead, it was decided to keep the design of
typical high-energy physics software frameworks (e.g. CMSSW, Athena,
FCCSW), and to implement it in python. This design boils down to:</p>

<ul>
  <li>a python configuration system, similar to the one we use in HEP full
frameworks like Gaudi.</li>
  <li>a Looper accessing the albers EDM events and running a sequence of
analyzers on each event.</li>
  <li>a common python event, created at the beginning of the processing of
each albers EDM event, and read/modified by the analyzers.</li>
</ul>

<p>the python event allows you to build the information you want into your
event, and allows the analyzers to communicate. At the end of the
processing of a given EDM event, the python event can be filled into a
flat tree using a specific kind of analyzer <a href="https://github.com/HEP-FCC/heppy/blob/tutorial/analyzers/SimpleTreeProducer.py">like this
one</a>
.</p>

<p><strong>The code consists of two packages:</strong></p>

<p><a href="https://github.com/HEP-FCC/heppy/tree/tutorial">The core package</a>
contains the following packages:</p>

<ul>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy/tree/tutorial/framework">framework</a></dt>
      <dd>Core modules: python configuration system, the looper, the python
event, etc.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy/tree/tutorial/analyzers">analyzers</a></dt>
      <dd>Generic analyzers</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy/tree/tutorial/statistics">statistics</a></dt>
      <dd>Modules for counting and averaging, histogramming,
tree production.</dd>
    </dl>
  </li>
  <li><a href="https://github.com/HEP-FCC/heppy/tree/tutorial/utils">utils</a> :
Miscellaneous utilities, like deltaR matching tools.</li>
</ul>

<p>It also contains a
<a href="https://github.com/HEP-FCC/heppy/tree/tutorial/scripts">scripts</a>
directory.</p>

<p><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial">The FCC-specific
package</a> contains
the following packages:</p>

<ul>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial/analyzers">analyzers</a></dt>
      <dd>FCC-specific analyzers;</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial/particles">particles</a></dt>
      <dd>python physics objects;</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial/fastsim">fastsim</a></dt>
      <dd>PAPAS fast simulation;</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial/fastsim">display</a></dt>
      <dd>event display;</dd>
    </dl>
  </li>
  <li><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial/tools">tools</a> :
various tools, like generated particle history analysis.</li>
</ul>

<p>The code is documented. To get more information on a given class, use
the python docstring functionality, for example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>python
import math
help(math)
</code></pre>
</div>

<h2 id="installation"><a href=""></a> Installation</h2>

<p>We assume that you have followed
<a href="./FccSoftwareEDM">FccSoftwareEDM</a>{.twikiLink} , which means that you
should have a base directory `  $FCC` containing the following packages:</p>

<ul>
  <li>albers-core</li>
  <li>fcc-edm</li>
  <li>analysis-cpp</li>
</ul>

<p>For this tutorial, these three packages are all needed.</p>

<p>First, make sure the `  FCC` environment variable is set properly. Do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>echo $FCC
</code></pre>
</div>

<p>If the command returns the path to the directory containing the 3
packages described above, you’re all set. Otherwise, go to this
directory and do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>export FCC=$PWD
</code></pre>
</div>

<p>We will now install the two heppy packages and a pythia inferface to the
FCC EDM:</p>

<ul>
  <li><a href="https://github.com/HEP-FCC/heppy/tree/tutorial">heppy</a></li>
  <li><a href="https://github.com/HEP-FCC/heppy_fcc/tree/tutorial">heppy_fcc</a></li>
  <li><a href="https://github.com/HEP-FCC/pythiafcc/tree/tutorial">pythiafcc</a></li>
</ul>

<p>Go back to your base directory and install the core heppy package:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd $FCC
git clone git@github.com:HEP-FCC/heppy.git
cd heppy
git checkout -t origin/tutorial
</code></pre>
</div>

<p>Follow the instructions in the README.md file.</p>

<p>Go back to your base directory and install the specific heppy_fcc
package:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd $FCC
git clone git@github.com:HEP-FCC/heppy_fcc.git
cd heppy_fcc
git checkout -t origin/tutorial
</code></pre>
</div>

<p>Follow the installation instructions in the README.md file, <strong>but do not
try to run yet</strong> .</p>

<p>Go back to your base directory and install the pythiafcc package:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd $FCC
git clone git@github.com:HEP-FCC/pythiafcc.git
cd pythiafcc
git checkout -t origin/tutorial
</code></pre>
</div>

<p>Follow the installation instructions in the README.md file.</p>

<h2 id="generating-an-edm-root-file-with-pythia"><a href=""></a> Generating an EDM root file with pythia</h2>

<p><a href="https://github.com/HEP-FCC/pythiafcc/tree/tutorial">pythiafcc</a> is a
pythia8 executable that writes all generated particles and vertices to
an FCC EDM root file.</p>

<p>It is currently set to produce inclusive gamma star/Z events at the Z
pole, decaying into d dbar. Later on you can modify the pythia8 cards in
<a href="https://github.com/HEP-FCC/pythiafcc/blob/tutorial/example/generate.cc">generate.cc</a>
and recompile if you want a different kind of events.</p>

<p>For now, just do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd $HEPPY_FCC/test
pythiafcc-generate
</code></pre>
</div>

<p>You should get a file called `  example.root` that are going to read in
the following exercises.</p>

<h2 id="exercises"><a href=""></a> Exercises</h2>

<h3 id="understanding-the-configuration-file"><a href=""></a> 1- Understanding the configuration file</h3>

<p>Have a detailed look at the configuration file,
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/test/simple_analysis_cfg.py">simple_analysis_cfg.py</a>
.</p>

<p><strong>For these exercises, we use ipython, an enhanced python interpreter.
If you don’t have ipython, just use python instead.</strong></p>

<p>Load it in python:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ipython -i simple_analysis_cfg.py
</code></pre>
</div>

<p>Print the component:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>print selectedComponents[0]

-&gt;
Component: example
        dataset_entries:   0
        files          :   ['example.root']
        isData         :   False
        isEmbed        :   False
        isMC           :   False
        tree_name      :   None
        triggers       :   None
</code></pre>
</div>

<p>Print the sequence of analyzers:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>print sequence

-&gt;
0 :
Analyzer: heppy_fcc.analyzers.FCCReader.FCCReader_1
        class_object   :
        instance_label :   1
        verbose        :   False :
1 :
Analyzer: heppy_fcc.analyzers.Recoil.Recoil_gen
        class_object   :
        instance_label :   gen
        particles      :   gen_particles_stable
        sqrts          :   91.0
        verbose        :   False :
2 :
Analyzer: heppy_fcc.analyzers.JetClusterizer.JetClusterizer_gen
        class_object   :
        instance_label :   gen
        particles      :   gen_particles_stable
        verbose        :   False :
3 :
Analyzer: heppy_fcc.analyzers.SimpleTreeProducer.SimpleTreeProducer_1
        class_object   :
        instance_label :   1
        verbose        :   False :
</code></pre>
</div>

<p>Now quit ipython.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
all objects created in this cfg file are just configuration objects.
These configuration objects will be passed to the actual analyzers that
contain your analysis code.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
In the future, when you use this event processing system in your
analysis, always make sure that all ingredients (components, analyzers)
are defined correctly by loading your configuration in python before
even trying to run.</p>

<h3 id="finding-existing-analysis-code"><a href=""></a> 2- Finding existing analysis code</h3>

<p>Open
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/test/simple_analysis_cfg.py">simple_analysis_cfg.py</a>
.</p>

<p>The configuration fragments for the analyzers look like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from heppy_fcc.analyzers.Recoil import Recoil
gen_recoil = cfg.Analyzer(
    Recoil,
    instance_label = 'gen',
    sqrts = 91.,
    particles = 'gen_particles_stable'
)
</code></pre>
</div>

<p>The first argument is a class object coming from
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/analyzers/Recoil.py">Recoil.py</a>
. The framework will use this class object to create an instance of this
class.</p>

<p>The second argument, `  instance_label` , is an instance label. This
argument is optional, and is useful in case several analyzers of the
same class are requested.</p>

<p>Have a look at the
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/analyzers/Recoil.py">Recoil.py</a>
module, and study the code. In particular, note how the analyzer reads
from the event and writes to it, and how it makes use of the parameters
defined in its configuration fragment.</p>

<p>Then study the code of the base class in
<a href="https://github.com/HEP-FCC/heppy/blob/tutorial/framework/analyzer.py">analyzer.py</a>
to see which methods are available in analyzers. You may also simply
have a look at the documentation of this class:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ipython
from heppy_fcc.analyzers.Recoil import Recoil
help(Recoil)
</code></pre>
</div>

<h3 id="running-interactively-on-one-component"><a href=""></a> 3- Running interactively on one component</h3>

<p>Run:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>heppy_loop.py Out simple_analysis_cfg.py -N 1000
</code></pre>
</div>

<p>You should see a healhy printout with, towards the end:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>number of events processed: 1000
</code></pre>
</div>

<p>In the ouput `  Out<code class="highlighter-rouge"> directory, you can find a component directory,
</code>  example<code class="highlighter-rouge"> . Investigate the contents of this component directory, and
of all directories within. Have a look at the text files, but ignore the
</code>  .pck` files</p>

<p>Fire up root (here we choose to use ipython + pyroot), and check the
main output tree:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ipython
from ROOT import TFile
f = TFile('Out/example/heppy_fcc.analyzers.SimpleTreeProducer.SimpleTreeProducer_1/tree.root')
f.ls()
t = f.Get('events')
t.Print()
t.Draw('recoil_visible_gen_m')
</code></pre>
</div>

<h3 id="multiprocessing-on-a-single-machine"><a href=""></a> 4- Multiprocessing on a single machine</h3>

<p>Copy your input file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cp example.root example_2.root
</code></pre>
</div>

<p>Edit
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/test/simple_analysis_cfg.py">simple_analysis_cfg.py</a>
and add the following lines, after the creation of the `  comp`
component object.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>comp.files.append('example_2.root')
comp.splitFactor = 2  # splitting the component in 2 chunks
</code></pre>
</div>

<p>As usual, load the configutation script in python, and print the
`  config` object. You should be able to see that the component now has
two input files and a splitFactor equal to 2.</p>

<p>Run again:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>heppy_loop.py Multi simple_analysis_cfg.py -N 1000
</code></pre>
</div>

<p>In the `  Multi` output directory, you have chunks. Each of these chunks
correspond to one of the threads you have run We’re going to add
everything up:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cd Multi
heppy_check.py *
heppy_hadd.py .
</code></pre>
</div>

<p>The first command checks that all chunks terminated correctly. The
second command adds the root files (with hadd), the cut-flow counters,
and the averages.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
To do multiprocessing, you can also define several components
corresponding to the samples you need to process. Each of these
components can have its own split factor.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
Check the number of processors on your machine ( `  cat /proc/cpuinfo`
), and define the number of threads accordingly.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
When debugging your code, make sure to have only one thread.</p>

<h3 id="using-papas-the-particle-flow-simulation"><a href=""></a> 5- Using PAPAS, the particle flow simulation</h3>

<p>PAPAS (PAramatrized PArticle Simulation) is a simulation of the particle
flow. It propagates stable generated particles through a simple detector
model.</p>

<p>In the tracker, charged particles may be detected as tracks, taking into
account the acceptance, efficiency, and momentum resolution of this
detector.</p>

<p>In the calorimeters, particles are detected as energy deposits. The
energy deposits are modelled by taking into account the following
detector properties: energy resolution, acceptance, energy thresholds,
and characteristic size. The latter is defined as the distance between
two clusters below which the two clusters cannot be resolved and are
considered as a single cluster.</p>

<p>A particle flow algorithm then runs over the simulated tracks and
clusters to identify and reconstruct charged hadrons, photons, and
neutral hadrons. These particles can then be used as an input to
higher-level algorithms like jet clustering, or directly in the
analysis.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
<strong>Electrons and muons are passed through PAPAS without any modification,
and the user is responsible for applying is own efficiency and
resolution models. The hadronic decay products of tau leptons are
simulated just like other hadrons and photons.</strong></p>

<p>A
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/fastsim/detectors/CMS.py">CMS-like</a>
detector model is provided as an example, and used in
<a href="https://github.com/HEP-FCC/heppy_fcc/blob/tutorial/test/simple_papas_cfg.py">simple_papas_cfg.py</a>
. Please inspect both modules carefully.</p>

<p>To run this confirguration file, do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>heppy_loop.py Papas simple_papas_cfg.py -N 1000
</code></pre>
</div>

<p>Then, check the output jet tree:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ipython
from ROOT import TFile
f = TFile('Papas/example/heppy_fcc.analyzers.JetTreeProducer.JetTreeProducer_papas/jet_tree.root')
f.ls()
t = f.Get('events')
t.Print()
t.Draw('jet1_e/jet1_gen_e&gt;&gt;h(40, 0, 2)', 'jet1_gen_e&gt;10 &amp;&amp; abs(jet1_gen_eta)&lt;3.')
</code></pre>
</div>

<p>This jet response plot is characteristic of what is to be expected with
particle flow. It is quite close from what would be obtained with the
CMS full simulation.</p>

<p>If you want to see an event display of event 10, do:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ipython
%run simple_papas_cfg.py 10
# and for next events:
next()
next()
# and so on
</code></pre>
</div>

<p>If you see nothing, it could be because the Z boson decayed into
neutrinos. In that case, just proceed to next event.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
This exercise shows how to run papas to produce a collection of
reconstructed particles. You can then build on this example to add
analysis modules and customized tree producers.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
A full documentation for PAPAS will be provided sometime this autumn.</p>

<p><span class="glyphicon glyphicon-info-sign" aria-hidden="true"> </span>
<strong>PAPAS is still in an experimental phase! No guarantee whatsoever,
please report bugs to Colin.</strong></p>

<p>– <a href="/twiki/bin/view/Main/ColinBernet"><span class="wikiUser ColinBernet"> ColinBernet
</span></a>{.twikiLink} - 08 Oct 2014</p>

      </div>
      <div class="col-md-2">    <ul class="list-group">
        <li class="list-group-header">
            <h4>External links</h4>
        </li>
        
            <li class="list-group-item">
                <a href='http://cern.ch/simba3/SelfSubscription.aspx?groupName=fcc-experiments-sw-dev'>FCCSW Mailing list</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://sft.its.cern.ch/jira/projects/FCC/'>FCCSW Jira Tracker</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/'>FCCSW on GitHub</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://phsft-jenkins.cern.ch/view/FCC/'>FCCSW Jenkins</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/FCCSW/blob/master/doc/CppCodingStyleGuidelines.md'>FCCSW C++ Style Guide</a>
            </li>
        
            <li class="list-group-item">
                <a href='https://github.com/HEP-FCC/FCCSW/blob/master/doc/GeneralCppGuidelines.md'>General C++ Guidelines</a>
            </li>
        
    </ul>
</div>
    </div>
    <script src="http://fccsw.web.cern.ch/fccsw/node_modules/jquery/dist/jquery.min.js"></script>
<script src="http://fccsw.web.cern.ch/fccsw/node_modules/bootstrap-sass/assets/javascripts/bootstrap.min.js"></script>


  </body>
</html>
