// Generated at Tue May  5 10:49:18 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/sw/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/lhcb/software/releases/LBSCRIPTS/LBSCRIPTS_v8r0/InstallArea/scripts/lcg-g++-4.8.1"
  GCCXML_CXXFLAGS="-D__STRICT_ANSI__"
  GCCXML_EXECUTABLE="/afs/cern.ch/sw/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/sw/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='1' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__STRICT_ANSI__='1' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__ATOMIC_HLE_RELEASE='131072' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__ATOMIC_HLE_ACQUIRE='65536' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.8.1"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__code_model_small__='1' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__FXSR__='1' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='8' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/afs/cern.ch/sw/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/share/gccxml-0.9/GCC/4.8" -isystem"/afs/cern.ch/sw/lcg/external/gcc/4.8.1/x86_64-slc6/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include" -isystem"/afs/cern.ch/sw/lcg/external/gcc/4.8.1/x86_64-slc6/lib/gcc/x86_64-unknown-linux-gnu/4.8.1/include-fixed" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.8.1/x86_64-slc6-gcc48-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.1/../../../../include/c++/4.8.1" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.8.1/x86_64-slc6-gcc48-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.1/../../../../include/c++/4.8.1/x86_64-unknown-linux-gnu" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.8.1/x86_64-slc6-gcc48-opt/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.8.1/../../../../include/c++/4.8.1/backward" -isystem"/usr/local/include" -isystem"/afs/cern.ch/sw/lcg/contrib/gcc/4.8.1/x86_64-slc6-gcc48-opt/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/sw/lcg/releases/LCG_68/gccxml/0.9.0_20131026/x86_64-slc6-gcc48-opt/share/gccxml-0.9"

Compiler info:
lcg-g++-4.8.1 (GCC) 4.8.1
Copyright (C) 2013 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/cern.ch/user/j/jhrdinka/FCC/FCCSW/DataObjects/dict/dictionary.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("albers") );
  ::Reflex::Type type_25 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_277 = ::Reflex::TypeBuilder(Reflex::Literal("Jet"));
  ::Reflex::Type type_18 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_6 = ::Reflex::TypeBuilder(Reflex::Literal("GenJet"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_408 = ::Reflex::TypeBuilder(Reflex::Literal("Point"));
  ::Reflex::Type type_1424 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1523 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1394 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_416 = ::Reflex::TypeBuilder(Reflex::Literal("BareJet"));
  ::Reflex::Type type_77 = ::Reflex::TypeBuilder(Reflex::Literal("Particle"));
  ::Reflex::Type type_782 = ::Reflex::TypeBuilder(Reflex::Literal("BareHit"));
  ::Reflex::Type type_201 = ::Reflex::TypeBuilder(Reflex::Literal("JetHandle"));
  ::Reflex::Type type_779 = ::Reflex::TypeBuilder(Reflex::Literal("EventInfo"));
  ::Reflex::Type type_119 = ::Reflex::TypeBuilder(Reflex::Literal("MCParticle"));
  ::Reflex::Type type_85 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_270 = ::Reflex::TypeBuilder(Reflex::Literal("BareCluster"));
  ::Reflex::Type type_534 = ::Reflex::TypeBuilder(Reflex::Literal("BareParticle"));
  ::Reflex::Type type_626 = ::Reflex::TypeBuilder(Reflex::Literal("GenJetHandle"));
  ::Reflex::Type type_42 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_261 = ::Reflex::TypeBuilder(Reflex::Literal("LorentzVector"));
  ::Reflex::Type type_913 = ::Reflex::TypeBuilder(Reflex::Literal("ParticleHandle"));
  ::Reflex::Type type_296 = ::Reflex::TypeBuilder(Reflex::Literal("EventInfoHandle"));
  ::Reflex::Type type_1535 = ::Reflex::TypeBuilder(Reflex::Literal("albers::Reader"));
  ::Reflex::Type type_315 = ::Reflex::TypeBuilder(Reflex::Literal("MCParticleHandle"));
  ::Reflex::Type type_1032 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Jet>"));
  ::Reflex::Type type_1537 = ::Reflex::TypeBuilder(Reflex::Literal("albers::Registry"));
  ::Reflex::Type type_1033 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<void*>"));
  ::Reflex::Type type_1031 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GenJet>"));
  ::Reflex::Type type_1145 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Jet>"));
  ::Reflex::Type type_529 = ::Reflex::TypeBuilder(Reflex::Literal("JetParticleAssociation"));
  ::Reflex::Type type_1029 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Particle>"));
  ::Reflex::Type type_1149 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<void*>"));
  ::Reflex::Type type_1030 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<EventInfo>"));
  ::Reflex::Type type_1144 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<GenJet>"));
  ::Reflex::Type type_1536 = ::Reflex::TypeBuilder(Reflex::Literal("albers::CollectionBase"));
  ::Reflex::Type type_1028 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<MCParticle>"));
  ::Reflex::Type type_1059 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_370 = ::Reflex::TypeBuilder(Reflex::Literal("GenJetParticleAssociation"));
  ::Reflex::Type type_1142 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Particle>"));
  ::Reflex::Type type_1143 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<EventInfo>"));
  ::Reflex::Type type_1035 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_1141 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<MCParticle>"));
  ::Reflex::Type type_229 = ::Reflex::TypeBuilder(Reflex::Literal("JetParticleAssociationHandle"));
  ::Reflex::Type type_1146 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_954 = ::Reflex::TypeBuilder(Reflex::Literal("GenJetParticleAssociationHandle"));
  ::Reflex::Type type_1027 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<JetParticleAssociation>"));
  ::Reflex::Type type_1036 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<albers::CollectionBase*>"));
  ::Reflex::Type type_1034 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_1026 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GenJetParticleAssociation>"));
  ::Reflex::Type type_1140 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<JetParticleAssociation>"));
  ::Reflex::Type type_1148 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<albers::CollectionBase*>"));
  ::Reflex::Type type_1147 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::basic_string<char> >"));
  ::Reflex::Type type_1139 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<GenJetParticleAssociation>"));
  ::Reflex::Type type_1255 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Jet,std::allocator<Jet> >"));
  ::Reflex::Type type_1559 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Jet> >"));
  ::Reflex::Type type_1259 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<void*,std::allocator<void*> >"));
  ::Reflex::Type type_1251 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenJet,std::allocator<GenJet> >"));
  ::Reflex::Type type_1563 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<void*> >"));
  ::Reflex::Type type_1555 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<GenJet> >"));
  ::Reflex::Type type_1558 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<Particle> >"));
  ::Reflex::Type type_1637 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >"));
  ::Reflex::Type type_1254 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Particle,std::allocator<Particle> >"));
  ::Reflex::Type type_1553 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<EventInfo> >"));
  ::Reflex::Type type_1557 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<MCParticle> >"));
  ::Reflex::Type type_1249 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<EventInfo,std::allocator<EventInfo> >"));
  ::Reflex::Type type_1645 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<void**,std::vector<void*> >"));
  ::Reflex::Type type_1561 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<unsigned int> >"));
  ::Reflex::Type type_1253 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<MCParticle,std::allocator<MCParticle> >"));
  ::Reflex::Type type_1629 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >"));
  ::Reflex::Type type_1638 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const Jet*,std::vector<Jet> >"));
  ::Reflex::Type type_1257 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >"));
  ::Reflex::Type type_1635 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >"));
  ::Reflex::Type type_1646 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<void* const*,std::vector<void*> >"));
  ::Reflex::Type type_1625 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >"));
  ::Reflex::Type type_1630 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const GenJet*,std::vector<GenJet> >"));
  ::Reflex::Type type_1556 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<JetParticleAssociation> >"));
  ::Reflex::Type type_1633 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >"));
  ::Reflex::Type type_1562 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<albers::CollectionBase*> >"));
  ::Reflex::Type type_1636 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const Particle*,std::vector<Particle> >"));
  ::Reflex::Type type_1560 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_1554 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<GenJetParticleAssociation> >"));
  ::Reflex::Type type_1626 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const EventInfo*,std::vector<EventInfo> >"));
  ::Reflex::Type type_1642 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_1634 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const MCParticle*,std::vector<MCParticle> >"));
  ::Reflex::Type type_1234 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> > >"));
  ::Reflex::Type type_1639 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_1242 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<void**,std::vector<void*> > >"));
  ::Reflex::Type type_1252 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<JetParticleAssociation,std::allocator<JetParticleAssociation> >"));
  ::Reflex::Type type_1226 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> > >"));
  ::Reflex::Type type_1233 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const Jet*,std::vector<Jet> > >"));
  ::Reflex::Type type_1258 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<albers::CollectionBase*,std::allocator<albers::CollectionBase*> >"));
  ::Reflex::Type type_1256 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_1232 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> > >"));
  ::Reflex::Type type_1241 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<void* const*,std::vector<void*> > >"));
  ::Reflex::Type type_1250 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> >"));
  ::Reflex::Type type_1222 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> > >"));
  ::Reflex::Type type_1225 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const GenJet*,std::vector<GenJet> > >"));
  ::Reflex::Type type_1631 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >"));
  ::Reflex::Type type_1230 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> > >"));
  ::Reflex::Type type_1231 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const Particle*,std::vector<Particle> > >"));
  ::Reflex::Type type_1643 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >"));
  ::Reflex::Type type_1640 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_1221 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const EventInfo*,std::vector<EventInfo> > >"));
  ::Reflex::Type type_1238 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1627 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >"));
  ::Reflex::Type type_1632 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const JetParticleAssociation*,std::vector<JetParticleAssociation> >"));
  ::Reflex::Type type_1229 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const MCParticle*,std::vector<MCParticle> > >"));
  ::Reflex::Type type_1644 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<albers::CollectionBase* const*,std::vector<albers::CollectionBase*> >"));
  ::Reflex::Type type_1641 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_1237 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1628 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >"));
  ::Reflex::Type type_1228 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> > >"));
  ::Reflex::Type type_1240 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> > >"));
  ::Reflex::Type type_1236 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_1224 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> > >"));
  ::Reflex::Type type_1227 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const JetParticleAssociation*,std::vector<JetParticleAssociation> > >"));
  ::Reflex::Type type_1239 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<albers::CollectionBase* const*,std::vector<albers::CollectionBase*> > >"));
  ::Reflex::Type type_1235 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_1223 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> > >"));
  ::Reflex::Type type_2885 = ::Reflex::ReferenceBuilder(type_6);
  ::Reflex::Type type_6c = ::Reflex::ConstBuilder(type_6);
  ::Reflex::Type type_2887 = ::Reflex::ReferenceBuilder(type_6c);
  ::Reflex::Type type_2753 = ::Reflex::ReferenceBuilder(type_77);
  ::Reflex::Type type_77c = ::Reflex::ConstBuilder(type_77);
  ::Reflex::Type type_2755 = ::Reflex::ReferenceBuilder(type_77c);
  ::Reflex::Type type_2687 = ::Reflex::ReferenceBuilder(type_119);
  ::Reflex::Type type_119c = ::Reflex::ConstBuilder(type_119);
  ::Reflex::Type type_2689 = ::Reflex::ReferenceBuilder(type_119c);
  ::Reflex::Type type_5663 = ::Reflex::PointerBuilder(type_1032);
  ::Reflex::Type type_5664 = ::Reflex::PointerBuilder(type_1537);
  ::Reflex::Type type_5665 = ::Reflex::ReferenceBuilder(type_201);
  ::Reflex::Type type_201c = ::Reflex::ConstBuilder(type_201);
  ::Reflex::Type type_1949 = ::Reflex::ReferenceBuilder(type_201c);
  ::Reflex::Type type_277c = ::Reflex::ConstBuilder(type_277);
  ::Reflex::Type type_2953 = ::Reflex::ReferenceBuilder(type_277c);
  ::Reflex::Type type_2951 = ::Reflex::ReferenceBuilder(type_277);
  ::Reflex::Type type_1537c = ::Reflex::ConstBuilder(type_1537);
  ::Reflex::Type type_5666 = ::Reflex::PointerBuilder(type_1537c);
  ::Reflex::Type type_5693 = ::Reflex::PointerBuilder(type_1027);
  ::Reflex::Type type_5694 = ::Reflex::ReferenceBuilder(type_229);
  ::Reflex::Type type_229c = ::Reflex::ConstBuilder(type_229);
  ::Reflex::Type type_1946 = ::Reflex::ReferenceBuilder(type_229c);
  ::Reflex::Type type_529c = ::Reflex::ConstBuilder(type_529);
  ::Reflex::Type type_2623 = ::Reflex::ReferenceBuilder(type_529c);
  ::Reflex::Type type_2621 = ::Reflex::ReferenceBuilder(type_529);
  ::Reflex::Type type_5698 = ::Reflex::ReferenceBuilder(type_261);
  ::Reflex::Type type_261c = ::Reflex::ConstBuilder(type_261);
  ::Reflex::Type type_5699 = ::Reflex::ReferenceBuilder(type_261c);
  ::Reflex::Type type_5700 = ::Reflex::ReferenceBuilder(type_270);
  ::Reflex::Type type_270c = ::Reflex::ConstBuilder(type_270);
  ::Reflex::Type type_5701 = ::Reflex::ReferenceBuilder(type_270c);
  ::Reflex::Type type_5705 = ::Reflex::PointerBuilder(type_1030);
  ::Reflex::Type type_5706 = ::Reflex::ReferenceBuilder(type_296);
  ::Reflex::Type type_296c = ::Reflex::ConstBuilder(type_296);
  ::Reflex::Type type_1943 = ::Reflex::ReferenceBuilder(type_296c);
  ::Reflex::Type type_779c = ::Reflex::ConstBuilder(type_779);
  ::Reflex::Type type_2821 = ::Reflex::ReferenceBuilder(type_779c);
  ::Reflex::Type type_2819 = ::Reflex::ReferenceBuilder(type_779);
  ::Reflex::Type type_5713 = ::Reflex::PointerBuilder(type_1028);
  ::Reflex::Type type_5714 = ::Reflex::ReferenceBuilder(type_315);
  ::Reflex::Type type_315c = ::Reflex::ConstBuilder(type_315);
  ::Reflex::Type type_1947 = ::Reflex::ReferenceBuilder(type_315c);
  ::Reflex::Type type_2555 = ::Reflex::ReferenceBuilder(type_370);
  ::Reflex::Type type_370c = ::Reflex::ConstBuilder(type_370);
  ::Reflex::Type type_2557 = ::Reflex::ReferenceBuilder(type_370c);
  ::Reflex::Type type_5724 = ::Reflex::ReferenceBuilder(type_408);
  ::Reflex::Type type_408c = ::Reflex::ConstBuilder(type_408);
  ::Reflex::Type type_5725 = ::Reflex::ReferenceBuilder(type_408c);
  ::Reflex::Type type_5731 = ::Reflex::ReferenceBuilder(type_416);
  ::Reflex::Type type_416c = ::Reflex::ConstBuilder(type_416);
  ::Reflex::Type type_5732 = ::Reflex::ReferenceBuilder(type_416c);
  ::Reflex::Type type_5797 = ::Reflex::ReferenceBuilder(type_534);
  ::Reflex::Type type_534c = ::Reflex::ConstBuilder(type_534);
  ::Reflex::Type type_5798 = ::Reflex::ReferenceBuilder(type_534c);
  ::Reflex::Type type_5809 = ::Reflex::PointerBuilder(type_1031);
  ::Reflex::Type type_5810 = ::Reflex::ReferenceBuilder(type_626);
  ::Reflex::Type type_626c = ::Reflex::ConstBuilder(type_626);
  ::Reflex::Type type_1945 = ::Reflex::ReferenceBuilder(type_626c);
  ::Reflex::Type type_5817 = ::Reflex::ReferenceBuilder(type_782);
  ::Reflex::Type type_782c = ::Reflex::ConstBuilder(type_782);
  ::Reflex::Type type_5818 = ::Reflex::ReferenceBuilder(type_782c);
  ::Reflex::Type type_5843 = ::Reflex::PointerBuilder(type_1029);
  ::Reflex::Type type_5844 = ::Reflex::ReferenceBuilder(type_913);
  ::Reflex::Type type_913c = ::Reflex::ConstBuilder(type_913);
  ::Reflex::Type type_1948 = ::Reflex::ReferenceBuilder(type_913c);
  ::Reflex::Type type_5845 = ::Reflex::PointerBuilder(type_1026);
  ::Reflex::Type type_5846 = ::Reflex::ReferenceBuilder(type_954);
  ::Reflex::Type type_954c = ::Reflex::ConstBuilder(type_954);
  ::Reflex::Type type_1944 = ::Reflex::ReferenceBuilder(type_954c);
  ::Reflex::Type type_2551 = ::Reflex::PointerBuilder(type_370);
  ::Reflex::Type type_2553 = ::Reflex::PointerBuilder(type_370c);
  ::Reflex::Type type_1218 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_42);
  ::Reflex::Type type_1176 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_18);
  ::Reflex::Type type_1139c = ::Reflex::ConstBuilder(type_1139);
  ::Reflex::Type type_5962 = ::Reflex::ReferenceBuilder(type_1139c);
  ::Reflex::Type type_1026c = ::Reflex::ConstBuilder(type_1026);
  ::Reflex::Type type_5963 = ::Reflex::ReferenceBuilder(type_1026c);
  ::Reflex::Type type_5964 = ::Reflex::ReferenceBuilder(type_1026);
  ::Reflex::Type type_2617 = ::Reflex::PointerBuilder(type_529);
  ::Reflex::Type type_2619 = ::Reflex::PointerBuilder(type_529c);
  ::Reflex::Type type_1140c = ::Reflex::ConstBuilder(type_1140);
  ::Reflex::Type type_5966 = ::Reflex::ReferenceBuilder(type_1140c);
  ::Reflex::Type type_1027c = ::Reflex::ConstBuilder(type_1027);
  ::Reflex::Type type_5967 = ::Reflex::ReferenceBuilder(type_1027c);
  ::Reflex::Type type_5968 = ::Reflex::ReferenceBuilder(type_1027);
  ::Reflex::Type type_2683 = ::Reflex::PointerBuilder(type_119);
  ::Reflex::Type type_2685 = ::Reflex::PointerBuilder(type_119c);
  ::Reflex::Type type_1141c = ::Reflex::ConstBuilder(type_1141);
  ::Reflex::Type type_5970 = ::Reflex::ReferenceBuilder(type_1141c);
  ::Reflex::Type type_1028c = ::Reflex::ConstBuilder(type_1028);
  ::Reflex::Type type_5971 = ::Reflex::ReferenceBuilder(type_1028c);
  ::Reflex::Type type_5972 = ::Reflex::ReferenceBuilder(type_1028);
  ::Reflex::Type type_2749 = ::Reflex::PointerBuilder(type_77);
  ::Reflex::Type type_2751 = ::Reflex::PointerBuilder(type_77c);
  ::Reflex::Type type_1142c = ::Reflex::ConstBuilder(type_1142);
  ::Reflex::Type type_5974 = ::Reflex::ReferenceBuilder(type_1142c);
  ::Reflex::Type type_1029c = ::Reflex::ConstBuilder(type_1029);
  ::Reflex::Type type_5975 = ::Reflex::ReferenceBuilder(type_1029c);
  ::Reflex::Type type_5976 = ::Reflex::ReferenceBuilder(type_1029);
  ::Reflex::Type type_2815 = ::Reflex::PointerBuilder(type_779);
  ::Reflex::Type type_2817 = ::Reflex::PointerBuilder(type_779c);
  ::Reflex::Type type_1143c = ::Reflex::ConstBuilder(type_1143);
  ::Reflex::Type type_5978 = ::Reflex::ReferenceBuilder(type_1143c);
  ::Reflex::Type type_1030c = ::Reflex::ConstBuilder(type_1030);
  ::Reflex::Type type_5979 = ::Reflex::ReferenceBuilder(type_1030c);
  ::Reflex::Type type_5980 = ::Reflex::ReferenceBuilder(type_1030);
  ::Reflex::Type type_2881 = ::Reflex::PointerBuilder(type_6);
  ::Reflex::Type type_2883 = ::Reflex::PointerBuilder(type_6c);
  ::Reflex::Type type_1144c = ::Reflex::ConstBuilder(type_1144);
  ::Reflex::Type type_5982 = ::Reflex::ReferenceBuilder(type_1144c);
  ::Reflex::Type type_1031c = ::Reflex::ConstBuilder(type_1031);
  ::Reflex::Type type_5983 = ::Reflex::ReferenceBuilder(type_1031c);
  ::Reflex::Type type_5984 = ::Reflex::ReferenceBuilder(type_1031);
  ::Reflex::Type type_2947 = ::Reflex::PointerBuilder(type_277);
  ::Reflex::Type type_2949 = ::Reflex::PointerBuilder(type_277c);
  ::Reflex::Type type_1145c = ::Reflex::ConstBuilder(type_1145);
  ::Reflex::Type type_5986 = ::Reflex::ReferenceBuilder(type_1145c);
  ::Reflex::Type type_1032c = ::Reflex::ConstBuilder(type_1032);
  ::Reflex::Type type_5987 = ::Reflex::ReferenceBuilder(type_1032c);
  ::Reflex::Type type_5988 = ::Reflex::ReferenceBuilder(type_1032);
  ::Reflex::Type type_263 = ::Reflex::PointerBuilder(type_1523);
  ::Reflex::Type type_1508 = ::Reflex::PointerBuilder(type_263);
  ::Reflex::Type type_263c = ::Reflex::ConstBuilder(type_263);
  ::Reflex::Type type_3014 = ::Reflex::PointerBuilder(type_263c);
  ::Reflex::Type type_3016 = ::Reflex::ReferenceBuilder(type_263);
  ::Reflex::Type type_3018 = ::Reflex::ReferenceBuilder(type_263c);
  ::Reflex::Type type_1149c = ::Reflex::ConstBuilder(type_1149);
  ::Reflex::Type type_5990 = ::Reflex::ReferenceBuilder(type_1149c);
  ::Reflex::Type type_1033c = ::Reflex::ConstBuilder(type_1033);
  ::Reflex::Type type_5991 = ::Reflex::ReferenceBuilder(type_1033c);
  ::Reflex::Type type_5992 = ::Reflex::ReferenceBuilder(type_1033);
  ::Reflex::Type type_3078 = ::Reflex::PointerBuilder(type_1059);
  ::Reflex::Type type_1059c = ::Reflex::ConstBuilder(type_1059);
  ::Reflex::Type type_3080 = ::Reflex::PointerBuilder(type_1059c);
  ::Reflex::Type type_3082 = ::Reflex::ReferenceBuilder(type_1059);
  ::Reflex::Type type_3084 = ::Reflex::ReferenceBuilder(type_1059c);
  ::Reflex::Type type_1147c = ::Reflex::ConstBuilder(type_1147);
  ::Reflex::Type type_5994 = ::Reflex::ReferenceBuilder(type_1147c);
  ::Reflex::Type type_1034c = ::Reflex::ConstBuilder(type_1034);
  ::Reflex::Type type_5995 = ::Reflex::ReferenceBuilder(type_1034c);
  ::Reflex::Type type_5996 = ::Reflex::ReferenceBuilder(type_1034);
  ::Reflex::Type type_1940 = ::Reflex::PointerBuilder(type_85);
  ::Reflex::Type type_85c = ::Reflex::ConstBuilder(type_85);
  ::Reflex::Type type_2518 = ::Reflex::PointerBuilder(type_85c);
  ::Reflex::Type type_3146 = ::Reflex::ReferenceBuilder(type_85);
  ::Reflex::Type type_2520 = ::Reflex::ReferenceBuilder(type_85c);
  ::Reflex::Type type_1146c = ::Reflex::ConstBuilder(type_1146);
  ::Reflex::Type type_5997 = ::Reflex::ReferenceBuilder(type_1146c);
  ::Reflex::Type type_1035c = ::Reflex::ConstBuilder(type_1035);
  ::Reflex::Type type_5998 = ::Reflex::ReferenceBuilder(type_1035c);
  ::Reflex::Type type_5999 = ::Reflex::ReferenceBuilder(type_1035);
  ::Reflex::Type type_3202 = ::Reflex::PointerBuilder(type_1536);
  ::Reflex::Type type_3208 = ::Reflex::PointerBuilder(type_3202);
  ::Reflex::Type type_3202c = ::Reflex::ConstBuilder(type_3202);
  ::Reflex::Type type_3210 = ::Reflex::PointerBuilder(type_3202c);
  ::Reflex::Type type_3212 = ::Reflex::ReferenceBuilder(type_3202);
  ::Reflex::Type type_3214 = ::Reflex::ReferenceBuilder(type_3202c);
  ::Reflex::Type type_1148c = ::Reflex::ConstBuilder(type_1148);
  ::Reflex::Type type_6001 = ::Reflex::ReferenceBuilder(type_1148c);
  ::Reflex::Type type_1036c = ::Reflex::ConstBuilder(type_1036);
  ::Reflex::Type type_6002 = ::Reflex::ReferenceBuilder(type_1036c);
  ::Reflex::Type type_6003 = ::Reflex::ReferenceBuilder(type_1036);
  ::Reflex::Type type_6457 = ::Reflex::PointerBuilder(type_1535);
  ::Reflex::Type type_6458 = ::Reflex::ReferenceBuilder(type_1537);
  ::Reflex::Type type_6459 = ::Reflex::ReferenceBuilder(type_1537c);
  ::Reflex::Type type_1072 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1059);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __GenJet
#undef __GenJet
#endif
class __GenJet {
  public:
  __GenJet();
  ::BareJet Core;
};
#ifdef __Particle
#undef __Particle
#endif
class __Particle {
  public:
  __Particle();
  ::BareParticle Core;
};
#ifdef __MCParticle
#undef __MCParticle
#endif
class __MCParticle {
  public:
  __MCParticle();
  ::BareParticle Core;
  ::Point Endvertex;
};
#ifdef __JetHandle
#undef __JetHandle
#endif
class __JetHandle {
  public:
  __JetHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __JetParticleAssociationHandle
#undef __JetParticleAssociationHandle
#endif
class __JetParticleAssociationHandle {
  public:
  __JetParticleAssociationHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __LorentzVector
#undef __LorentzVector
#endif
class __LorentzVector {
  public:
  __LorentzVector();
  float Phi;
  float Eta;
  float Mass;
  float Pt;
};
#ifdef __BareCluster
#undef __BareCluster
#endif
class __BareCluster {
  public:
  __BareCluster();
  ::Point position;
  float Energy;
  unsigned int Bits;
  float Time;
};
#ifdef __Jet
#undef __Jet
#endif
class __Jet {
  public:
  __Jet();
  ::BareJet Core;
};
#ifdef __EventInfoHandle
#undef __EventInfoHandle
#endif
class __EventInfoHandle {
  public:
  __EventInfoHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __MCParticleHandle
#undef __MCParticleHandle
#endif
class __MCParticleHandle {
  public:
  __MCParticleHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __GenJetParticleAssociation
#undef __GenJetParticleAssociation
#endif
class __GenJetParticleAssociation {
  public:
  __GenJetParticleAssociation();
  ::GenJetHandle Jet;
  ::MCParticleHandle Particle;
};
#ifdef __Point
#undef __Point
#endif
class __Point {
  public:
  __Point();
  float Y;
  float X;
  float Z;
};
#ifdef __BareJet
#undef __BareJet
#endif
class __BareJet {
  public:
  __BareJet();
  unsigned int Bits;
  ::LorentzVector P4;
  float Area;
};
#ifdef __JetParticleAssociation
#undef __JetParticleAssociation
#endif
class __JetParticleAssociation {
  public:
  __JetParticleAssociation();
  ::JetHandle Jet;
  ::ParticleHandle Particle;
};
#ifdef __BareParticle
#undef __BareParticle
#endif
class __BareParticle {
  public:
  __BareParticle();
  unsigned int Status;
  unsigned int Bits;
  int Type;
  ::Point Vertex;
  ::LorentzVector P4;
};
#ifdef __GenJetHandle
#undef __GenJetHandle
#endif
class __GenJetHandle {
  public:
  __GenJetHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __EventInfo
#undef __EventInfo
#endif
class __EventInfo {
  public:
  __EventInfo();
  int Number;
};
#ifdef __BareHit
#undef __BareHit
#endif
class __BareHit {
  public:
  __BareHit();
  float Energy;
  unsigned int Bits;
  unsigned int Cellid;
  float Time;
};
#ifdef __ParticleHandle
#undef __ParticleHandle
#endif
class __ParticleHandle {
  public:
  __ParticleHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __GenJetParticleAssociationHandle
#undef __GenJetParticleAssociationHandle
#endif
class __GenJetParticleAssociationHandle {
  public:
  __GenJetParticleAssociationHandle();
  int m_index;
  int m_containerID;
  void* m_container;
  void* m_registry;
};
#ifdef __std__vector_GenJetParticleAssociation_
#undef __std__vector_GenJetParticleAssociation_
#endif
class __std__vector_GenJetParticleAssociation_ : protected ::std::_Vector_base<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > {
  public:
  __std__vector_GenJetParticleAssociation_();
};
#ifdef __std__vector_JetParticleAssociation_
#undef __std__vector_JetParticleAssociation_
#endif
class __std__vector_JetParticleAssociation_ : protected ::std::_Vector_base<JetParticleAssociation,std::allocator<JetParticleAssociation> > {
  public:
  __std__vector_JetParticleAssociation_();
};
#ifdef __std__vector_MCParticle_
#undef __std__vector_MCParticle_
#endif
class __std__vector_MCParticle_ : protected ::std::_Vector_base<MCParticle,std::allocator<MCParticle> > {
  public:
  __std__vector_MCParticle_();
};
#ifdef __std__vector_Particle_
#undef __std__vector_Particle_
#endif
class __std__vector_Particle_ : protected ::std::_Vector_base<Particle,std::allocator<Particle> > {
  public:
  __std__vector_Particle_();
};
#ifdef __std__vector_EventInfo_
#undef __std__vector_EventInfo_
#endif
class __std__vector_EventInfo_ : protected ::std::_Vector_base<EventInfo,std::allocator<EventInfo> > {
  public:
  __std__vector_EventInfo_();
};
#ifdef __std__vector_GenJet_
#undef __std__vector_GenJet_
#endif
class __std__vector_GenJet_ : protected ::std::_Vector_base<GenJet,std::allocator<GenJet> > {
  public:
  __std__vector_GenJet_();
};
#ifdef __std__vector_Jet_
#undef __std__vector_Jet_
#endif
class __std__vector_Jet_ : protected ::std::_Vector_base<Jet,std::allocator<Jet> > {
  public:
  __std__vector_Jet_();
};
#ifdef __std__vector_voidp_
#undef __std__vector_voidp_
#endif
class __std__vector_voidp_ : protected ::std::_Vector_base<void*,std::allocator<void*> > {
  public:
  __std__vector_voidp_();
};
#ifdef __std__vector_std__basic_string_char_s_
#undef __std__vector_std__basic_string_char_s_
#endif
class __std__vector_std__basic_string_char_s_ : protected ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > {
  public:
  __std__vector_std__basic_string_char_s_();
};
#ifdef __std__vector_unsignedsint_
#undef __std__vector_unsignedsint_
#endif
class __std__vector_unsignedsint_ : protected ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > {
  public:
  __std__vector_unsignedsint_();
};
#ifdef __std__vector_albers__CollectionBasep_
#undef __std__vector_albers__CollectionBasep_
#endif
class __std__vector_albers__CollectionBasep_ : protected ::std::_Vector_base<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > {
  public:
  __std__vector_albers__CollectionBasep_();
};
#ifdef __albers__Registry
#undef __albers__Registry
#endif
class __albers__Registry {
  public:
  __albers__Registry();
  ::std::vector<void*> m_addresses;
  ::std::vector<albers::CollectionBase*> m_collections;
  ::std::vector<unsigned int> m_collectionIDs;
  ::std::vector<std::basic_string<char> > m_names;
  void* m_reader;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class GenJet -------------------------------
static void destructor_1390(void*, void * o, const std::vector<void*>&, void *) {
(((::GenJet*)o)->::GenJet::~GenJet)();
}
static  void operator_1391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenJet*)o)->operator=)(*(const ::GenJet*)arg[0]);
  else   (((::GenJet*)o)->operator=)(*(const ::GenJet*)arg[0]);
}

static void constructor_1392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJet(*(const ::GenJet*)arg[0]);
  else ::new(mem) ::GenJet(*(const ::GenJet*)arg[0]);
}

static void constructor_1393( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJet();
  else ::new(mem) ::GenJet();
}

static void method_newdel_6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenJet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenJet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenJet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenJet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenJet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenJet -------------------------------
void __GenJet_db_datamem(Reflex::Class*);
void __GenJet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenJet_datamem_bld(&__GenJet_db_datamem);
Reflex::GenreflexMemberBuilder __GenJet_funcmem_bld(&__GenJet_db_funcmem);
void __GenJet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenJet"), typeid(::GenJet), sizeof(::GenJet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenJet"), destructor_1390, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2885, type_2887), Reflex::Literal("operator="), operator_1391, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2887), Reflex::Literal("GenJet"), constructor_1392, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenJet"), constructor_1393, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenJet_datamem_bld);
}

//------Delayed data member builder for class GenJet -------------------
void __GenJet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_416, Reflex::Literal("Core"), OffsetOf(__shadow__::__GenJet, Core), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class GenJet -------------------
void __GenJet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Particle -------------------------------
static void destructor_1480(void*, void * o, const std::vector<void*>&, void *) {
(((::Particle*)o)->::Particle::~Particle)();
}
static  void operator_1481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Particle*)o)->operator=)(*(const ::Particle*)arg[0]);
  else   (((::Particle*)o)->operator=)(*(const ::Particle*)arg[0]);
}

static void constructor_1482( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Particle(*(const ::Particle*)arg[0]);
  else ::new(mem) ::Particle(*(const ::Particle*)arg[0]);
}

static void constructor_1483( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Particle();
  else ::new(mem) ::Particle();
}

static void method_newdel_77( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Particle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Particle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Particle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Particle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Particle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Particle -------------------------------
void __Particle_db_datamem(Reflex::Class*);
void __Particle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Particle_datamem_bld(&__Particle_db_datamem);
Reflex::GenreflexMemberBuilder __Particle_funcmem_bld(&__Particle_db_funcmem);
void __Particle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Particle"), typeid(::Particle), sizeof(::Particle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Particle"), destructor_1480, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_2755), Reflex::Literal("operator="), operator_1481, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2755), Reflex::Literal("Particle"), constructor_1482, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Particle"), constructor_1483, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_77, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Particle_datamem_bld);
}

//------Delayed data member builder for class Particle -------------------
void __Particle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_534, Reflex::Literal("Core"), OffsetOf(__shadow__::__Particle, Core), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Particle -------------------
void __Particle_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class MCParticle -------------------------------
static void destructor_1501(void*, void * o, const std::vector<void*>&, void *) {
(((::MCParticle*)o)->::MCParticle::~MCParticle)();
}
static  void operator_1502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MCParticle*)o)->operator=)(*(const ::MCParticle*)arg[0]);
  else   (((::MCParticle*)o)->operator=)(*(const ::MCParticle*)arg[0]);
}

static void constructor_1503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MCParticle(*(const ::MCParticle*)arg[0]);
  else ::new(mem) ::MCParticle(*(const ::MCParticle*)arg[0]);
}

static void constructor_1504( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MCParticle();
  else ::new(mem) ::MCParticle();
}

static void method_newdel_119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MCParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MCParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MCParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MCParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MCParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MCParticle -------------------------------
void __MCParticle_db_datamem(Reflex::Class*);
void __MCParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MCParticle_datamem_bld(&__MCParticle_db_datamem);
Reflex::GenreflexMemberBuilder __MCParticle_funcmem_bld(&__MCParticle_db_funcmem);
void __MCParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MCParticle"), typeid(::MCParticle), sizeof(::MCParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MCParticle"), destructor_1501, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_2689), Reflex::Literal("operator="), operator_1502, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2689), Reflex::Literal("MCParticle"), constructor_1503, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MCParticle"), constructor_1504, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MCParticle_datamem_bld);
}

//------Delayed data member builder for class MCParticle -------------------
void __MCParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_534, Reflex::Literal("Core"), OffsetOf(__shadow__::__MCParticle, Core), ::Reflex::PUBLIC)
  .AddDataMember(type_408, Reflex::Literal("Endvertex"), OffsetOf(__shadow__::__MCParticle, Endvertex), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class MCParticle -------------------
void __MCParticle_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class JetHandle -------------------------------
static void destructor_1663(void*, void * o, const std::vector<void*>&, void *) {
(((::JetHandle*)o)->::JetHandle::~JetHandle)();
}
static  void operator_1664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JetHandle*)o)->operator=)(*(const ::JetHandle*)arg[0]);
  else   (((::JetHandle*)o)->operator=)(*(const ::JetHandle*)arg[0]);
}

static void constructor_1665( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetHandle(*(const ::JetHandle*)arg[0]);
  else ::new(mem) ::JetHandle(*(const ::JetHandle*)arg[0]);
}

static void constructor_1666( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetHandle();
  else ::new(mem) ::JetHandle();
}

static  void method_1667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::JetHandle*)o)->isAvailable)());
  else   (((const ::JetHandle*)o)->isAvailable)();
}

static  void method_1668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::JetHandle*)o)->read)();
  else   (((const ::JetHandle*)o)->read)();
}

static  void method_1669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JetHandle*)o)->mod)();
  else   (((::JetHandle*)o)->mod)();
}

static  void method_1670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JetHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_1671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JetHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_1672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::JetHandle*)o)->operator==)(*(const ::JetHandle*)arg[0]));
  else   (((const ::JetHandle*)o)->operator==)(*(const ::JetHandle*)arg[0]);
}

static void method_newdel_201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JetHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JetHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JetHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JetHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JetHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetHandle -------------------------------
void __JetHandle_db_datamem(Reflex::Class*);
void __JetHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JetHandle_datamem_bld(&__JetHandle_db_datamem);
Reflex::GenreflexMemberBuilder __JetHandle_funcmem_bld(&__JetHandle_db_funcmem);
void __JetHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JetHandle"), typeid(::JetHandle), sizeof(::JetHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetHandle"), destructor_1663, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5665, type_1949), Reflex::Literal("operator="), operator_1664, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1949), Reflex::Literal("JetHandle"), constructor_1665, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetHandle"), constructor_1666, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JetHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__JetHandle_funcmem_bld);
}

//------Delayed data member builder for class JetHandle -------------------
void __JetHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__JetHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__JetHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5663, Reflex::Literal("m_container"), OffsetOf(__shadow__::__JetHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__JetHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class JetHandle -------------------
void __JetHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_1667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2953), Reflex::Literal("read"), method_1668, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951), Reflex::Literal("mod"), method_1669, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_1670, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_1671, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1949), Reflex::Literal("operator=="), operator_1672, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class JetParticleAssociationHandle -------------------------------
static void destructor_1709(void*, void * o, const std::vector<void*>&, void *) {
(((::JetParticleAssociationHandle*)o)->::JetParticleAssociationHandle::~JetParticleAssociationHandle)();
}
static  void operator_1710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JetParticleAssociationHandle*)o)->operator=)(*(const ::JetParticleAssociationHandle*)arg[0]);
  else   (((::JetParticleAssociationHandle*)o)->operator=)(*(const ::JetParticleAssociationHandle*)arg[0]);
}

static void constructor_1711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetParticleAssociationHandle(*(const ::JetParticleAssociationHandle*)arg[0]);
  else ::new(mem) ::JetParticleAssociationHandle(*(const ::JetParticleAssociationHandle*)arg[0]);
}

static void constructor_1712( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetParticleAssociationHandle();
  else ::new(mem) ::JetParticleAssociationHandle();
}

static  void method_1713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::JetParticleAssociationHandle*)o)->isAvailable)());
  else   (((const ::JetParticleAssociationHandle*)o)->isAvailable)();
}

static  void method_1714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::JetParticleAssociationHandle*)o)->read)();
  else   (((const ::JetParticleAssociationHandle*)o)->read)();
}

static  void method_1715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JetParticleAssociationHandle*)o)->mod)();
  else   (((::JetParticleAssociationHandle*)o)->mod)();
}

static  void method_1716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JetParticleAssociationHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_1717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::JetParticleAssociationHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_1718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::JetParticleAssociationHandle*)o)->operator==)(*(const ::JetParticleAssociationHandle*)arg[0]));
  else   (((const ::JetParticleAssociationHandle*)o)->operator==)(*(const ::JetParticleAssociationHandle*)arg[0]);
}

static void method_newdel_229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JetParticleAssociationHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JetParticleAssociationHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JetParticleAssociationHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JetParticleAssociationHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JetParticleAssociationHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetParticleAssociationHandle -------------------------------
void __JetParticleAssociationHandle_db_datamem(Reflex::Class*);
void __JetParticleAssociationHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JetParticleAssociationHandle_datamem_bld(&__JetParticleAssociationHandle_db_datamem);
Reflex::GenreflexMemberBuilder __JetParticleAssociationHandle_funcmem_bld(&__JetParticleAssociationHandle_db_funcmem);
void __JetParticleAssociationHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JetParticleAssociationHandle"), typeid(::JetParticleAssociationHandle), sizeof(::JetParticleAssociationHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetParticleAssociationHandle"), destructor_1709, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5694, type_1946), Reflex::Literal("operator="), operator_1710, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1946), Reflex::Literal("JetParticleAssociationHandle"), constructor_1711, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetParticleAssociationHandle"), constructor_1712, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JetParticleAssociationHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__JetParticleAssociationHandle_funcmem_bld);
}

//------Delayed data member builder for class JetParticleAssociationHandle -------------------
void __JetParticleAssociationHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__JetParticleAssociationHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__JetParticleAssociationHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5693, Reflex::Literal("m_container"), OffsetOf(__shadow__::__JetParticleAssociationHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__JetParticleAssociationHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class JetParticleAssociationHandle -------------------
void __JetParticleAssociationHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_1713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2623), Reflex::Literal("read"), method_1714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2621), Reflex::Literal("mod"), method_1715, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_1716, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_1717, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1946), Reflex::Literal("operator=="), operator_1718, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class LorentzVector -------------------------------
static void destructor_1740(void*, void * o, const std::vector<void*>&, void *) {
(((::LorentzVector*)o)->::LorentzVector::~LorentzVector)();
}
static  void operator_1741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::LorentzVector*)o)->operator=)(*(const ::LorentzVector*)arg[0]);
  else   (((::LorentzVector*)o)->operator=)(*(const ::LorentzVector*)arg[0]);
}

static void constructor_1742( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LorentzVector(*(const ::LorentzVector*)arg[0]);
  else ::new(mem) ::LorentzVector(*(const ::LorentzVector*)arg[0]);
}

static void constructor_1743( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::LorentzVector();
  else ::new(mem) ::LorentzVector();
}

static void method_newdel_261( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::LorentzVector >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::LorentzVector >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::LorentzVector >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::LorentzVector >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::LorentzVector >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class LorentzVector -------------------------------
void __LorentzVector_db_datamem(Reflex::Class*);
void __LorentzVector_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __LorentzVector_datamem_bld(&__LorentzVector_db_datamem);
Reflex::GenreflexMemberBuilder __LorentzVector_funcmem_bld(&__LorentzVector_db_funcmem);
void __LorentzVector_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("LorentzVector"), typeid(::LorentzVector), sizeof(::LorentzVector), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~LorentzVector"), destructor_1740, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5698, type_5699), Reflex::Literal("operator="), operator_1741, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5699), Reflex::Literal("LorentzVector"), constructor_1742, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("LorentzVector"), constructor_1743, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_261, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__LorentzVector_datamem_bld);
}

//------Delayed data member builder for class LorentzVector -------------------
void __LorentzVector_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1394, Reflex::Literal("Phi"), OffsetOf(__shadow__::__LorentzVector, Phi), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Eta"), OffsetOf(__shadow__::__LorentzVector, Eta), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Mass"), OffsetOf(__shadow__::__LorentzVector, Mass), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Pt"), OffsetOf(__shadow__::__LorentzVector, Pt), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class LorentzVector -------------------
void __LorentzVector_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BareCluster -------------------------------
static void destructor_1749(void*, void * o, const std::vector<void*>&, void *) {
(((::BareCluster*)o)->::BareCluster::~BareCluster)();
}
static  void operator_1750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BareCluster*)o)->operator=)(*(const ::BareCluster*)arg[0]);
  else   (((::BareCluster*)o)->operator=)(*(const ::BareCluster*)arg[0]);
}

static void constructor_1751( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareCluster(*(const ::BareCluster*)arg[0]);
  else ::new(mem) ::BareCluster(*(const ::BareCluster*)arg[0]);
}

static void constructor_1752( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareCluster();
  else ::new(mem) ::BareCluster();
}

static void method_newdel_270( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BareCluster >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BareCluster >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BareCluster >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BareCluster >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BareCluster >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BareCluster -------------------------------
void __BareCluster_db_datamem(Reflex::Class*);
void __BareCluster_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BareCluster_datamem_bld(&__BareCluster_db_datamem);
Reflex::GenreflexMemberBuilder __BareCluster_funcmem_bld(&__BareCluster_db_funcmem);
void __BareCluster_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BareCluster"), typeid(::BareCluster), sizeof(::BareCluster), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BareCluster"), destructor_1749, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5700, type_5701), Reflex::Literal("operator="), operator_1750, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5701), Reflex::Literal("BareCluster"), constructor_1751, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BareCluster"), constructor_1752, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_270, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BareCluster_datamem_bld);
}

//------Delayed data member builder for class BareCluster -------------------
void __BareCluster_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_408, Reflex::Literal("position"), OffsetOf(__shadow__::__BareCluster, position), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Energy"), OffsetOf(__shadow__::__BareCluster, Energy), ::Reflex::PUBLIC)
  .AddDataMember(type_85, Reflex::Literal("Bits"), OffsetOf(__shadow__::__BareCluster, Bits), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Time"), OffsetOf(__shadow__::__BareCluster, Time), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BareCluster -------------------
void __BareCluster_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Jet -------------------------------
static void destructor_1754(void*, void * o, const std::vector<void*>&, void *) {
(((::Jet*)o)->::Jet::~Jet)();
}
static  void operator_1755( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Jet*)o)->operator=)(*(const ::Jet*)arg[0]);
  else   (((::Jet*)o)->operator=)(*(const ::Jet*)arg[0]);
}

static void constructor_1756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Jet(*(const ::Jet*)arg[0]);
  else ::new(mem) ::Jet(*(const ::Jet*)arg[0]);
}

static void constructor_1757( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Jet();
  else ::new(mem) ::Jet();
}

static void method_newdel_277( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Jet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Jet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Jet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Jet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Jet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Jet -------------------------------
void __Jet_db_datamem(Reflex::Class*);
void __Jet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Jet_datamem_bld(&__Jet_db_datamem);
Reflex::GenreflexMemberBuilder __Jet_funcmem_bld(&__Jet_db_funcmem);
void __Jet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Jet"), typeid(::Jet), sizeof(::Jet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Jet"), destructor_1754, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_2953), Reflex::Literal("operator="), operator_1755, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2953), Reflex::Literal("Jet"), constructor_1756, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Jet"), constructor_1757, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_277, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Jet_datamem_bld);
}

//------Delayed data member builder for class Jet -------------------
void __Jet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_416, Reflex::Literal("Core"), OffsetOf(__shadow__::__Jet, Core), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Jet -------------------
void __Jet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class EventInfoHandle -------------------------------
static void destructor_1768(void*, void * o, const std::vector<void*>&, void *) {
(((::EventInfoHandle*)o)->::EventInfoHandle::~EventInfoHandle)();
}
static  void operator_1769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::EventInfoHandle*)o)->operator=)(*(const ::EventInfoHandle*)arg[0]);
  else   (((::EventInfoHandle*)o)->operator=)(*(const ::EventInfoHandle*)arg[0]);
}

static void constructor_1770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventInfoHandle(*(const ::EventInfoHandle*)arg[0]);
  else ::new(mem) ::EventInfoHandle(*(const ::EventInfoHandle*)arg[0]);
}

static void constructor_1771( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventInfoHandle();
  else ::new(mem) ::EventInfoHandle();
}

static  void method_1772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::EventInfoHandle*)o)->isAvailable)());
  else   (((const ::EventInfoHandle*)o)->isAvailable)();
}

static  void method_1773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::EventInfoHandle*)o)->read)();
  else   (((const ::EventInfoHandle*)o)->read)();
}

static  void method_1774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::EventInfoHandle*)o)->mod)();
  else   (((::EventInfoHandle*)o)->mod)();
}

static  void method_1775( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::EventInfoHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_1776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::EventInfoHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_1777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::EventInfoHandle*)o)->operator==)(*(const ::EventInfoHandle*)arg[0]));
  else   (((const ::EventInfoHandle*)o)->operator==)(*(const ::EventInfoHandle*)arg[0]);
}

static void method_newdel_296( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::EventInfoHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::EventInfoHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::EventInfoHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::EventInfoHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::EventInfoHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EventInfoHandle -------------------------------
void __EventInfoHandle_db_datamem(Reflex::Class*);
void __EventInfoHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __EventInfoHandle_datamem_bld(&__EventInfoHandle_db_datamem);
Reflex::GenreflexMemberBuilder __EventInfoHandle_funcmem_bld(&__EventInfoHandle_db_funcmem);
void __EventInfoHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("EventInfoHandle"), typeid(::EventInfoHandle), sizeof(::EventInfoHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EventInfoHandle"), destructor_1768, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5706, type_1943), Reflex::Literal("operator="), operator_1769, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1943), Reflex::Literal("EventInfoHandle"), constructor_1770, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EventInfoHandle"), constructor_1771, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_296, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__EventInfoHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__EventInfoHandle_funcmem_bld);
}

//------Delayed data member builder for class EventInfoHandle -------------------
void __EventInfoHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__EventInfoHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__EventInfoHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5705, Reflex::Literal("m_container"), OffsetOf(__shadow__::__EventInfoHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__EventInfoHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class EventInfoHandle -------------------
void __EventInfoHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_1772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2821), Reflex::Literal("read"), method_1773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("mod"), method_1774, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_1775, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_1776, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1943), Reflex::Literal("operator=="), operator_1777, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class MCParticleHandle -------------------------------
static void destructor_1795(void*, void * o, const std::vector<void*>&, void *) {
(((::MCParticleHandle*)o)->::MCParticleHandle::~MCParticleHandle)();
}
static  void operator_1796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MCParticleHandle*)o)->operator=)(*(const ::MCParticleHandle*)arg[0]);
  else   (((::MCParticleHandle*)o)->operator=)(*(const ::MCParticleHandle*)arg[0]);
}

static void constructor_1797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MCParticleHandle(*(const ::MCParticleHandle*)arg[0]);
  else ::new(mem) ::MCParticleHandle(*(const ::MCParticleHandle*)arg[0]);
}

static void constructor_1798( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MCParticleHandle();
  else ::new(mem) ::MCParticleHandle();
}

static  void method_1799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::MCParticleHandle*)o)->isAvailable)());
  else   (((const ::MCParticleHandle*)o)->isAvailable)();
}

static  void method_1800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::MCParticleHandle*)o)->read)();
  else   (((const ::MCParticleHandle*)o)->read)();
}

static  void method_1801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MCParticleHandle*)o)->mod)();
  else   (((::MCParticleHandle*)o)->mod)();
}

static  void method_1802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MCParticleHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_1803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MCParticleHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_1804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::MCParticleHandle*)o)->operator==)(*(const ::MCParticleHandle*)arg[0]));
  else   (((const ::MCParticleHandle*)o)->operator==)(*(const ::MCParticleHandle*)arg[0]);
}

static void method_newdel_315( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MCParticleHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MCParticleHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MCParticleHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MCParticleHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MCParticleHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MCParticleHandle -------------------------------
void __MCParticleHandle_db_datamem(Reflex::Class*);
void __MCParticleHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MCParticleHandle_datamem_bld(&__MCParticleHandle_db_datamem);
Reflex::GenreflexMemberBuilder __MCParticleHandle_funcmem_bld(&__MCParticleHandle_db_funcmem);
void __MCParticleHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MCParticleHandle"), typeid(::MCParticleHandle), sizeof(::MCParticleHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MCParticleHandle"), destructor_1795, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5714, type_1947), Reflex::Literal("operator="), operator_1796, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1947), Reflex::Literal("MCParticleHandle"), constructor_1797, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MCParticleHandle"), constructor_1798, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_315, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MCParticleHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MCParticleHandle_funcmem_bld);
}

//------Delayed data member builder for class MCParticleHandle -------------------
void __MCParticleHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__MCParticleHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__MCParticleHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5713, Reflex::Literal("m_container"), OffsetOf(__shadow__::__MCParticleHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__MCParticleHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class MCParticleHandle -------------------
void __MCParticleHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_1799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2689), Reflex::Literal("read"), method_1800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("mod"), method_1801, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_1802, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_1803, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1947), Reflex::Literal("operator=="), operator_1804, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class GenJetParticleAssociation -------------------------------
static void destructor_1822(void*, void * o, const std::vector<void*>&, void *) {
(((::GenJetParticleAssociation*)o)->::GenJetParticleAssociation::~GenJetParticleAssociation)();
}
static  void operator_1823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenJetParticleAssociation*)o)->operator=)(*(const ::GenJetParticleAssociation*)arg[0]);
  else   (((::GenJetParticleAssociation*)o)->operator=)(*(const ::GenJetParticleAssociation*)arg[0]);
}

static void constructor_1824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJetParticleAssociation(*(const ::GenJetParticleAssociation*)arg[0]);
  else ::new(mem) ::GenJetParticleAssociation(*(const ::GenJetParticleAssociation*)arg[0]);
}

static void constructor_1825( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJetParticleAssociation();
  else ::new(mem) ::GenJetParticleAssociation();
}

static void method_newdel_370( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociation >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociation >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociation >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociation >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociation >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenJetParticleAssociation -------------------------------
void __GenJetParticleAssociation_db_datamem(Reflex::Class*);
void __GenJetParticleAssociation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenJetParticleAssociation_datamem_bld(&__GenJetParticleAssociation_db_datamem);
Reflex::GenreflexMemberBuilder __GenJetParticleAssociation_funcmem_bld(&__GenJetParticleAssociation_db_funcmem);
void __GenJetParticleAssociation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenJetParticleAssociation"), typeid(::GenJetParticleAssociation), sizeof(::GenJetParticleAssociation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenJetParticleAssociation"), destructor_1822, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2555, type_2557), Reflex::Literal("operator="), operator_1823, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2557), Reflex::Literal("GenJetParticleAssociation"), constructor_1824, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenJetParticleAssociation"), constructor_1825, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_370, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenJetParticleAssociation_datamem_bld);
}

//------Delayed data member builder for class GenJetParticleAssociation -------------------
void __GenJetParticleAssociation_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_626, Reflex::Literal("Jet"), OffsetOf(__shadow__::__GenJetParticleAssociation, Jet), ::Reflex::PUBLIC)
  .AddDataMember(type_315, Reflex::Literal("Particle"), OffsetOf(__shadow__::__GenJetParticleAssociation, Particle), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class GenJetParticleAssociation -------------------
void __GenJetParticleAssociation_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Point -------------------------------
static void destructor_1836(void*, void * o, const std::vector<void*>&, void *) {
(((::Point*)o)->::Point::~Point)();
}
static  void operator_1837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::Point*)o)->operator=)(*(const ::Point*)arg[0]);
  else   (((::Point*)o)->operator=)(*(const ::Point*)arg[0]);
}

static void constructor_1838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Point(*(const ::Point*)arg[0]);
  else ::new(mem) ::Point(*(const ::Point*)arg[0]);
}

static void constructor_1839( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::Point();
  else ::new(mem) ::Point();
}

static void method_newdel_408( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::Point >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::Point >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::Point >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::Point >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::Point >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Point -------------------------------
void __Point_db_datamem(Reflex::Class*);
void __Point_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __Point_datamem_bld(&__Point_db_datamem);
Reflex::GenreflexMemberBuilder __Point_funcmem_bld(&__Point_db_funcmem);
void __Point_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("Point"), typeid(::Point), sizeof(::Point), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Point"), destructor_1836, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5724, type_5725), Reflex::Literal("operator="), operator_1837, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5725), Reflex::Literal("Point"), constructor_1838, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Point"), constructor_1839, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_408, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__Point_datamem_bld);
}

//------Delayed data member builder for class Point -------------------
void __Point_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1394, Reflex::Literal("Y"), OffsetOf(__shadow__::__Point, Y), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("X"), OffsetOf(__shadow__::__Point, X), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Z"), OffsetOf(__shadow__::__Point, Z), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Point -------------------
void __Point_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BareJet -------------------------------
static void destructor_1844(void*, void * o, const std::vector<void*>&, void *) {
(((::BareJet*)o)->::BareJet::~BareJet)();
}
static  void operator_1845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BareJet*)o)->operator=)(*(const ::BareJet*)arg[0]);
  else   (((::BareJet*)o)->operator=)(*(const ::BareJet*)arg[0]);
}

static void constructor_1846( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareJet(*(const ::BareJet*)arg[0]);
  else ::new(mem) ::BareJet(*(const ::BareJet*)arg[0]);
}

static void constructor_1847( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareJet();
  else ::new(mem) ::BareJet();
}

static void method_newdel_416( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BareJet >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BareJet >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BareJet >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BareJet >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BareJet >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BareJet -------------------------------
void __BareJet_db_datamem(Reflex::Class*);
void __BareJet_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BareJet_datamem_bld(&__BareJet_db_datamem);
Reflex::GenreflexMemberBuilder __BareJet_funcmem_bld(&__BareJet_db_funcmem);
void __BareJet_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BareJet"), typeid(::BareJet), sizeof(::BareJet), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BareJet"), destructor_1844, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5731, type_5732), Reflex::Literal("operator="), operator_1845, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5732), Reflex::Literal("BareJet"), constructor_1846, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BareJet"), constructor_1847, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_416, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BareJet_datamem_bld);
}

//------Delayed data member builder for class BareJet -------------------
void __BareJet_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_85, Reflex::Literal("Bits"), OffsetOf(__shadow__::__BareJet, Bits), ::Reflex::PUBLIC)
  .AddDataMember(type_261, Reflex::Literal("P4"), OffsetOf(__shadow__::__BareJet, P4), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Area"), OffsetOf(__shadow__::__BareJet, Area), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BareJet -------------------
void __BareJet_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class JetParticleAssociation -------------------------------
static void destructor_1927(void*, void * o, const std::vector<void*>&, void *) {
(((::JetParticleAssociation*)o)->::JetParticleAssociation::~JetParticleAssociation)();
}
static  void operator_1928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::JetParticleAssociation*)o)->operator=)(*(const ::JetParticleAssociation*)arg[0]);
  else   (((::JetParticleAssociation*)o)->operator=)(*(const ::JetParticleAssociation*)arg[0]);
}

static void constructor_1929( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetParticleAssociation(*(const ::JetParticleAssociation*)arg[0]);
  else ::new(mem) ::JetParticleAssociation(*(const ::JetParticleAssociation*)arg[0]);
}

static void constructor_1930( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::JetParticleAssociation();
  else ::new(mem) ::JetParticleAssociation();
}

static void method_newdel_529( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::JetParticleAssociation >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::JetParticleAssociation >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::JetParticleAssociation >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::JetParticleAssociation >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::JetParticleAssociation >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class JetParticleAssociation -------------------------------
void __JetParticleAssociation_db_datamem(Reflex::Class*);
void __JetParticleAssociation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __JetParticleAssociation_datamem_bld(&__JetParticleAssociation_db_datamem);
Reflex::GenreflexMemberBuilder __JetParticleAssociation_funcmem_bld(&__JetParticleAssociation_db_funcmem);
void __JetParticleAssociation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("JetParticleAssociation"), typeid(::JetParticleAssociation), sizeof(::JetParticleAssociation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~JetParticleAssociation"), destructor_1927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2621, type_2623), Reflex::Literal("operator="), operator_1928, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2623), Reflex::Literal("JetParticleAssociation"), constructor_1929, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("JetParticleAssociation"), constructor_1930, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_529, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__JetParticleAssociation_datamem_bld);
}

//------Delayed data member builder for class JetParticleAssociation -------------------
void __JetParticleAssociation_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_201, Reflex::Literal("Jet"), OffsetOf(__shadow__::__JetParticleAssociation, Jet), ::Reflex::PUBLIC)
  .AddDataMember(type_913, Reflex::Literal("Particle"), OffsetOf(__shadow__::__JetParticleAssociation, Particle), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class JetParticleAssociation -------------------
void __JetParticleAssociation_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BareParticle -------------------------------
static void destructor_1936(void*, void * o, const std::vector<void*>&, void *) {
(((::BareParticle*)o)->::BareParticle::~BareParticle)();
}
static  void operator_1937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BareParticle*)o)->operator=)(*(const ::BareParticle*)arg[0]);
  else   (((::BareParticle*)o)->operator=)(*(const ::BareParticle*)arg[0]);
}

static void constructor_1938( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareParticle(*(const ::BareParticle*)arg[0]);
  else ::new(mem) ::BareParticle(*(const ::BareParticle*)arg[0]);
}

static void constructor_1939( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareParticle();
  else ::new(mem) ::BareParticle();
}

static void method_newdel_534( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BareParticle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BareParticle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BareParticle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BareParticle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BareParticle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BareParticle -------------------------------
void __BareParticle_db_datamem(Reflex::Class*);
void __BareParticle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BareParticle_datamem_bld(&__BareParticle_db_datamem);
Reflex::GenreflexMemberBuilder __BareParticle_funcmem_bld(&__BareParticle_db_funcmem);
void __BareParticle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BareParticle"), typeid(::BareParticle), sizeof(::BareParticle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BareParticle"), destructor_1936, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5797, type_5798), Reflex::Literal("operator="), operator_1937, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5798), Reflex::Literal("BareParticle"), constructor_1938, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BareParticle"), constructor_1939, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_534, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BareParticle_datamem_bld);
}

//------Delayed data member builder for class BareParticle -------------------
void __BareParticle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_85, Reflex::Literal("Status"), OffsetOf(__shadow__::__BareParticle, Status), ::Reflex::PUBLIC)
  .AddDataMember(type_85, Reflex::Literal("Bits"), OffsetOf(__shadow__::__BareParticle, Bits), ::Reflex::PUBLIC)
  .AddDataMember(type_25, Reflex::Literal("Type"), OffsetOf(__shadow__::__BareParticle, Type), ::Reflex::PUBLIC)
  .AddDataMember(type_408, Reflex::Literal("Vertex"), OffsetOf(__shadow__::__BareParticle, Vertex), ::Reflex::PUBLIC)
  .AddDataMember(type_261, Reflex::Literal("P4"), OffsetOf(__shadow__::__BareParticle, P4), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BareParticle -------------------
void __BareParticle_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class GenJetHandle -------------------------------
static void destructor_1965(void*, void * o, const std::vector<void*>&, void *) {
(((::GenJetHandle*)o)->::GenJetHandle::~GenJetHandle)();
}
static  void operator_1966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenJetHandle*)o)->operator=)(*(const ::GenJetHandle*)arg[0]);
  else   (((::GenJetHandle*)o)->operator=)(*(const ::GenJetHandle*)arg[0]);
}

static void constructor_1967( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJetHandle(*(const ::GenJetHandle*)arg[0]);
  else ::new(mem) ::GenJetHandle(*(const ::GenJetHandle*)arg[0]);
}

static void constructor_1968( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJetHandle();
  else ::new(mem) ::GenJetHandle();
}

static  void method_1969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenJetHandle*)o)->isAvailable)());
  else   (((const ::GenJetHandle*)o)->isAvailable)();
}

static  void method_1970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenJetHandle*)o)->read)();
  else   (((const ::GenJetHandle*)o)->read)();
}

static  void method_1971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenJetHandle*)o)->mod)();
  else   (((::GenJetHandle*)o)->mod)();
}

static  void method_1972( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenJetHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_1973( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenJetHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_1974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenJetHandle*)o)->operator==)(*(const ::GenJetHandle*)arg[0]));
  else   (((const ::GenJetHandle*)o)->operator==)(*(const ::GenJetHandle*)arg[0]);
}

static void method_newdel_626( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenJetHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenJetHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenJetHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenJetHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenJetHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenJetHandle -------------------------------
void __GenJetHandle_db_datamem(Reflex::Class*);
void __GenJetHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenJetHandle_datamem_bld(&__GenJetHandle_db_datamem);
Reflex::GenreflexMemberBuilder __GenJetHandle_funcmem_bld(&__GenJetHandle_db_funcmem);
void __GenJetHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenJetHandle"), typeid(::GenJetHandle), sizeof(::GenJetHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenJetHandle"), destructor_1965, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5810, type_1945), Reflex::Literal("operator="), operator_1966, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1945), Reflex::Literal("GenJetHandle"), constructor_1967, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenJetHandle"), constructor_1968, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_626, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenJetHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenJetHandle_funcmem_bld);
}

//------Delayed data member builder for class GenJetHandle -------------------
void __GenJetHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__GenJetHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__GenJetHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5809, Reflex::Literal("m_container"), OffsetOf(__shadow__::__GenJetHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__GenJetHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class GenJetHandle -------------------
void __GenJetHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_1969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2887), Reflex::Literal("read"), method_1970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2885), Reflex::Literal("mod"), method_1971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_1972, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_1973, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1945), Reflex::Literal("operator=="), operator_1974, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class EventInfo -------------------------------
static void destructor_2012(void*, void * o, const std::vector<void*>&, void *) {
(((::EventInfo*)o)->::EventInfo::~EventInfo)();
}
static  void operator_2013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::EventInfo*)o)->operator=)(*(const ::EventInfo*)arg[0]);
  else   (((::EventInfo*)o)->operator=)(*(const ::EventInfo*)arg[0]);
}

static void constructor_2014( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventInfo(*(const ::EventInfo*)arg[0]);
  else ::new(mem) ::EventInfo(*(const ::EventInfo*)arg[0]);
}

static void constructor_2015( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventInfo();
  else ::new(mem) ::EventInfo();
}

static void method_newdel_779( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::EventInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::EventInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::EventInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::EventInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::EventInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EventInfo -------------------------------
void __EventInfo_db_datamem(Reflex::Class*);
void __EventInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __EventInfo_datamem_bld(&__EventInfo_db_datamem);
Reflex::GenreflexMemberBuilder __EventInfo_funcmem_bld(&__EventInfo_db_funcmem);
void __EventInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("EventInfo"), typeid(::EventInfo), sizeof(::EventInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EventInfo"), destructor_2012, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_2821), Reflex::Literal("operator="), operator_2013, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2821), Reflex::Literal("EventInfo"), constructor_2014, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EventInfo"), constructor_2015, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_779, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__EventInfo_datamem_bld);
}

//------Delayed data member builder for class EventInfo -------------------
void __EventInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("Number"), OffsetOf(__shadow__::__EventInfo, Number), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class EventInfo -------------------
void __EventInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BareHit -------------------------------
static void destructor_2021(void*, void * o, const std::vector<void*>&, void *) {
(((::BareHit*)o)->::BareHit::~BareHit)();
}
static  void operator_2022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BareHit*)o)->operator=)(*(const ::BareHit*)arg[0]);
  else   (((::BareHit*)o)->operator=)(*(const ::BareHit*)arg[0]);
}

static void constructor_2023( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareHit(*(const ::BareHit*)arg[0]);
  else ::new(mem) ::BareHit(*(const ::BareHit*)arg[0]);
}

static void constructor_2024( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BareHit();
  else ::new(mem) ::BareHit();
}

static void method_newdel_782( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BareHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BareHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BareHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BareHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BareHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BareHit -------------------------------
void __BareHit_db_datamem(Reflex::Class*);
void __BareHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BareHit_datamem_bld(&__BareHit_db_datamem);
Reflex::GenreflexMemberBuilder __BareHit_funcmem_bld(&__BareHit_db_funcmem);
void __BareHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BareHit"), typeid(::BareHit), sizeof(::BareHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BareHit"), destructor_2021, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5817, type_5818), Reflex::Literal("operator="), operator_2022, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5818), Reflex::Literal("BareHit"), constructor_2023, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BareHit"), constructor_2024, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_782, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BareHit_datamem_bld);
}

//------Delayed data member builder for class BareHit -------------------
void __BareHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1394, Reflex::Literal("Energy"), OffsetOf(__shadow__::__BareHit, Energy), ::Reflex::PUBLIC)
  .AddDataMember(type_85, Reflex::Literal("Bits"), OffsetOf(__shadow__::__BareHit, Bits), ::Reflex::PUBLIC)
  .AddDataMember(type_85, Reflex::Literal("Cellid"), OffsetOf(__shadow__::__BareHit, Cellid), ::Reflex::PUBLIC)
  .AddDataMember(type_1394, Reflex::Literal("Time"), OffsetOf(__shadow__::__BareHit, Time), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BareHit -------------------
void __BareHit_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ParticleHandle -------------------------------
static void destructor_2082(void*, void * o, const std::vector<void*>&, void *) {
(((::ParticleHandle*)o)->::ParticleHandle::~ParticleHandle)();
}
static  void operator_2083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ParticleHandle*)o)->operator=)(*(const ::ParticleHandle*)arg[0]);
  else   (((::ParticleHandle*)o)->operator=)(*(const ::ParticleHandle*)arg[0]);
}

static void constructor_2084( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ParticleHandle(*(const ::ParticleHandle*)arg[0]);
  else ::new(mem) ::ParticleHandle(*(const ::ParticleHandle*)arg[0]);
}

static void constructor_2085( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ParticleHandle();
  else ::new(mem) ::ParticleHandle();
}

static  void method_2086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ParticleHandle*)o)->isAvailable)());
  else   (((const ::ParticleHandle*)o)->isAvailable)();
}

static  void method_2087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::ParticleHandle*)o)->read)();
  else   (((const ::ParticleHandle*)o)->read)();
}

static  void method_2088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ParticleHandle*)o)->mod)();
  else   (((::ParticleHandle*)o)->mod)();
}

static  void method_2089( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ParticleHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_2090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ParticleHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_2091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::ParticleHandle*)o)->operator==)(*(const ::ParticleHandle*)arg[0]));
  else   (((const ::ParticleHandle*)o)->operator==)(*(const ::ParticleHandle*)arg[0]);
}

static void method_newdel_913( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ParticleHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ParticleHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ParticleHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ParticleHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ParticleHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ParticleHandle -------------------------------
void __ParticleHandle_db_datamem(Reflex::Class*);
void __ParticleHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ParticleHandle_datamem_bld(&__ParticleHandle_db_datamem);
Reflex::GenreflexMemberBuilder __ParticleHandle_funcmem_bld(&__ParticleHandle_db_funcmem);
void __ParticleHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ParticleHandle"), typeid(::ParticleHandle), sizeof(::ParticleHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ParticleHandle"), destructor_2082, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5844, type_1948), Reflex::Literal("operator="), operator_2083, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1948), Reflex::Literal("ParticleHandle"), constructor_2084, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ParticleHandle"), constructor_2085, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ParticleHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ParticleHandle_funcmem_bld);
}

//------Delayed data member builder for class ParticleHandle -------------------
void __ParticleHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__ParticleHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__ParticleHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5843, Reflex::Literal("m_container"), OffsetOf(__shadow__::__ParticleHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__ParticleHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class ParticleHandle -------------------
void __ParticleHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_2086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("read"), method_2087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753), Reflex::Literal("mod"), method_2088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_2089, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_2090, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1948), Reflex::Literal("operator=="), operator_2091, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class GenJetParticleAssociationHandle -------------------------------
static void destructor_2099(void*, void * o, const std::vector<void*>&, void *) {
(((::GenJetParticleAssociationHandle*)o)->::GenJetParticleAssociationHandle::~GenJetParticleAssociationHandle)();
}
static  void operator_2100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenJetParticleAssociationHandle*)o)->operator=)(*(const ::GenJetParticleAssociationHandle*)arg[0]);
  else   (((::GenJetParticleAssociationHandle*)o)->operator=)(*(const ::GenJetParticleAssociationHandle*)arg[0]);
}

static void constructor_2101( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJetParticleAssociationHandle(*(const ::GenJetParticleAssociationHandle*)arg[0]);
  else ::new(mem) ::GenJetParticleAssociationHandle(*(const ::GenJetParticleAssociationHandle*)arg[0]);
}

static void constructor_2102( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GenJetParticleAssociationHandle();
  else ::new(mem) ::GenJetParticleAssociationHandle();
}

static  void method_2103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenJetParticleAssociationHandle*)o)->isAvailable)());
  else   (((const ::GenJetParticleAssociationHandle*)o)->isAvailable)();
}

static  void method_2104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GenJetParticleAssociationHandle*)o)->read)();
  else   (((const ::GenJetParticleAssociationHandle*)o)->read)();
}

static  void method_2105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GenJetParticleAssociationHandle*)o)->mod)();
  else   (((::GenJetParticleAssociationHandle*)o)->mod)();
}

static  void method_2106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenJetParticleAssociationHandle*)o)->prepareForWrite)((const ::albers::Registry*)arg[0]);
}

static  void method_2107( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GenJetParticleAssociationHandle*)o)->prepareAfterRead)((::albers::Registry*)arg[0]);
}

static  void operator_2108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::GenJetParticleAssociationHandle*)o)->operator==)(*(const ::GenJetParticleAssociationHandle*)arg[0]));
  else   (((const ::GenJetParticleAssociationHandle*)o)->operator==)(*(const ::GenJetParticleAssociationHandle*)arg[0]);
}

static void method_newdel_954( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociationHandle >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociationHandle >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociationHandle >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociationHandle >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GenJetParticleAssociationHandle >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GenJetParticleAssociationHandle -------------------------------
void __GenJetParticleAssociationHandle_db_datamem(Reflex::Class*);
void __GenJetParticleAssociationHandle_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GenJetParticleAssociationHandle_datamem_bld(&__GenJetParticleAssociationHandle_db_datamem);
Reflex::GenreflexMemberBuilder __GenJetParticleAssociationHandle_funcmem_bld(&__GenJetParticleAssociationHandle_db_funcmem);
void __GenJetParticleAssociationHandle_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GenJetParticleAssociationHandle"), typeid(::GenJetParticleAssociationHandle), sizeof(::GenJetParticleAssociationHandle), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenJetParticleAssociationHandle"), destructor_2099, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5846, type_1944), Reflex::Literal("operator="), operator_2100, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1944), Reflex::Literal("GenJetParticleAssociationHandle"), constructor_2101, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenJetParticleAssociationHandle"), constructor_2102, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_954, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GenJetParticleAssociationHandle_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GenJetParticleAssociationHandle_funcmem_bld);
}

//------Delayed data member builder for class GenJetParticleAssociationHandle -------------------
void __GenJetParticleAssociationHandle_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_25, Reflex::Literal("m_index"), OffsetOf(__shadow__::__GenJetParticleAssociationHandle, m_index), ::Reflex::PRIVATE)
  .AddDataMember(type_25, Reflex::Literal("m_containerID"), OffsetOf(__shadow__::__GenJetParticleAssociationHandle, m_containerID), ::Reflex::PRIVATE)
  .AddDataMember(type_5845, Reflex::Literal("m_container"), OffsetOf(__shadow__::__GenJetParticleAssociationHandle, m_container), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_5664, Reflex::Literal("m_registry"), OffsetOf(__shadow__::__GenJetParticleAssociationHandle, m_registry), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class GenJetParticleAssociationHandle -------------------
void __GenJetParticleAssociationHandle_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("isAvailable"), method_2103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2557), Reflex::Literal("read"), method_2104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2555), Reflex::Literal("mod"), method_2105, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5666), Reflex::Literal("prepareForWrite"), method_2106, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5664), Reflex::Literal("prepareAfterRead"), method_2107, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424, type_1944), Reflex::Literal("operator=="), operator_2108, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class vector<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > -------------------------------
static void constructor_2566( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJetParticleAssociation>();
  else ::new(mem) ::std::vector<GenJetParticleAssociation>();
}

static void constructor_2567( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJetParticleAssociation>(*(const ::std::allocator<GenJetParticleAssociation>*)arg[0]);
  else ::new(mem) ::std::vector<GenJetParticleAssociation>(*(const ::std::allocator<GenJetParticleAssociation>*)arg[0]);
}

static void constructor_2568( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJetParticleAssociation>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<GenJetParticleAssociation>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::GenJetParticleAssociation*)arg[1]);
  else ::new(mem) ::std::vector<GenJetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::GenJetParticleAssociation*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::GenJetParticleAssociation*)arg[1],
      *(const ::std::allocator<GenJetParticleAssociation>*)arg[2]);
  else ::new(mem) ::std::vector<GenJetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::GenJetParticleAssociation*)arg[1],
      *(const ::std::allocator<GenJetParticleAssociation>*)arg[2]);
  }
}

static void constructor_2569( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJetParticleAssociation>(*(const ::std::vector<GenJetParticleAssociation>*)arg[0]);
  else ::new(mem) ::std::vector<GenJetParticleAssociation>(*(const ::std::vector<GenJetParticleAssociation>*)arg[0]);
}

static void destructor_2570(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<GenJetParticleAssociation>*)o)->::std::vector<GenJetParticleAssociation>::~vector)();
}
static  void operator_2571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJetParticleAssociation>*)o)->operator=)(*(const ::std::vector<GenJetParticleAssociation>*)arg[0]);
  else   (((::std::vector<GenJetParticleAssociation>*)o)->operator=)(*(const ::std::vector<GenJetParticleAssociation>*)arg[0]);
}

static  void method_2572( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::GenJetParticleAssociation*)arg[1]);
}

static  void method_2573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((::std::vector<GenJetParticleAssociation>*)o)->begin)());
  else   (((::std::vector<GenJetParticleAssociation>*)o)->begin)();
}

static  void method_2574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((const ::std::vector<GenJetParticleAssociation>*)o)->begin)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->begin)();
}

static  void method_2575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((::std::vector<GenJetParticleAssociation>*)o)->end)());
  else   (((::std::vector<GenJetParticleAssociation>*)o)->end)();
}

static  void method_2576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((const ::std::vector<GenJetParticleAssociation>*)o)->end)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->end)();
}

static  void method_2581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenJetParticleAssociation>*)o)->size)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->size)();
}

static  void method_2582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenJetParticleAssociation>*)o)->max_size)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->max_size)();
}

static  void method_2583( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<GenJetParticleAssociation>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<GenJetParticleAssociation>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::GenJetParticleAssociation*)arg[1]);
  }
}

static  void method_2584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenJetParticleAssociation>*)o)->capacity)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->capacity)();
}

static  void method_2585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<GenJetParticleAssociation>*)o)->empty)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->empty)();
}

static  void method_2586( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenJetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenJetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJetParticleAssociation>*)o)->front)();
  else   (((::std::vector<GenJetParticleAssociation>*)o)->front)();
}

static  void method_2593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJetParticleAssociation>*)o)->front)();
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->front)();
}

static  void method_2594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJetParticleAssociation>*)o)->back)();
  else   (((::std::vector<GenJetParticleAssociation>*)o)->back)();
}

static  void method_2595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJetParticleAssociation>*)o)->back)();
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->back)();
}

static  void method_2596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<GenJetParticleAssociation>*)o)->data)());
  else   (((::std::vector<GenJetParticleAssociation>*)o)->data)();
}

static  void method_2597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<GenJetParticleAssociation>*)o)->data)());
  else   (((const ::std::vector<GenJetParticleAssociation>*)o)->data)();
}

static  void method_2598( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->push_back)(*(const ::GenJetParticleAssociation*)arg[0]);
}

static  void method_2599( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->pop_back)();
}

static  void method_2600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((::std::vector<GenJetParticleAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0],
    *(const ::GenJetParticleAssociation*)arg[1]));
  else   (((::std::vector<GenJetParticleAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0],
    *(const ::GenJetParticleAssociation*)arg[1]);
}

static  void method_2601( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::GenJetParticleAssociation*)arg[2]);
}

static  void method_2602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((::std::vector<GenJetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0]));
  else   (((::std::vector<GenJetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0]);
}

static  void method_2603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >)((((::std::vector<GenJetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[1]));
  else   (((::std::vector<GenJetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenJetParticleAssociation*,std::vector<GenJetParticleAssociation> >*)arg[1]);
}

static  void method_2604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->swap)(*(::std::vector<GenJetParticleAssociation>*)arg[0]);
}

static  void method_2605( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenJetParticleAssociation>*)o)->clear)();
}

static void method_newdel_1026( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<GenJetParticleAssociation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<GenJetParticleAssociation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<GenJetParticleAssociation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<GenJetParticleAssociation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<GenJetParticleAssociation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> >")), ::Reflex::BaseOffset< ::std::vector<GenJetParticleAssociation>,::std::_Vector_base<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x22( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<GenJetParticleAssociation> >::Generate();
  else ::Reflex::Proxy< ::std::vector<GenJetParticleAssociation> >::Generate();
}

//------Dictionary for class vector<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > -------------------------------
void __std__vector_GenJetParticleAssociation__db_datamem(Reflex::Class*);
void __std__vector_GenJetParticleAssociation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_GenJetParticleAssociation__datamem_bld(&__std__vector_GenJetParticleAssociation__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_GenJetParticleAssociation__funcmem_bld(&__std__vector_GenJetParticleAssociation__db_funcmem);
void __std__vector_GenJetParticleAssociation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<GenJetParticleAssociation>"), typeid(::std::vector<GenJetParticleAssociation>), sizeof(::std::vector<GenJetParticleAssociation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1250, ::Reflex::BaseOffset< ::std::vector<GenJetParticleAssociation>, ::std::_Vector_base<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_370, Reflex::Literal("std::vector<GenJetParticleAssociation>::_Alloc_value_type"))
  .AddTypedef(type_1250, Reflex::Literal("std::vector<GenJetParticleAssociation>::_Base"))
  .AddTypedef(type_1139, Reflex::Literal("std::vector<GenJetParticleAssociation>::_Tp_alloc_type"))
  .AddTypedef(type_1554, Reflex::Literal("std::vector<GenJetParticleAssociation>::_Alloc_traits"))
  .AddTypedef(type_370, Reflex::Literal("std::vector<GenJetParticleAssociation>::value_type"))
  .AddTypedef(type_2551, Reflex::Literal("std::vector<GenJetParticleAssociation>::pointer"))
  .AddTypedef(type_2553, Reflex::Literal("std::vector<GenJetParticleAssociation>::const_pointer"))
  .AddTypedef(type_2555, Reflex::Literal("std::vector<GenJetParticleAssociation>::reference"))
  .AddTypedef(type_2557, Reflex::Literal("std::vector<GenJetParticleAssociation>::const_reference"))
  .AddTypedef(type_1627, Reflex::Literal("std::vector<GenJetParticleAssociation>::iterator"))
  .AddTypedef(type_1628, Reflex::Literal("std::vector<GenJetParticleAssociation>::const_iterator"))
  .AddTypedef(type_1223, Reflex::Literal("std::vector<GenJetParticleAssociation>::const_reverse_iterator"))
  .AddTypedef(type_1224, Reflex::Literal("std::vector<GenJetParticleAssociation>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<GenJetParticleAssociation>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<GenJetParticleAssociation>::difference_type"))
  .AddTypedef(type_1139, Reflex::Literal("std::vector<GenJetParticleAssociation>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2566, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5962), Reflex::Literal("vector"), constructor_2567, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2557, type_5962), Reflex::Literal("vector"), constructor_2568, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5963), Reflex::Literal("vector"), constructor_2569, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2570, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1026, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x22, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_GenJetParticleAssociation__funcmem_bld);
}

//------Delayed data member builder for class vector<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > -------------------
void __std__vector_GenJetParticleAssociation__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<GenJetParticleAssociation,std::allocator<GenJetParticleAssociation> > -------------------
void __std__vector_GenJetParticleAssociation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5964, type_5963), Reflex::Literal("operator="), operator_2571, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2557), Reflex::Literal("assign"), method_2572, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1627), Reflex::Literal("begin"), method_2573, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1628), Reflex::Literal("begin"), method_2574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1627), Reflex::Literal("end"), method_2575, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1628), Reflex::Literal("end"), method_2576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_370), Reflex::Literal("resize"), method_2583, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2586, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2555, type_1218), Reflex::Literal("operator[]"), operator_2587, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2557, type_1218), Reflex::Literal("operator[]"), operator_2588, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2555, type_1218), Reflex::Literal("at"), method_2590, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2557, type_1218), Reflex::Literal("at"), method_2591, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2555), Reflex::Literal("front"), method_2592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2557), Reflex::Literal("front"), method_2593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2555), Reflex::Literal("back"), method_2594, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2557), Reflex::Literal("back"), method_2595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2551), Reflex::Literal("data"), method_2596, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2553), Reflex::Literal("data"), method_2597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2557), Reflex::Literal("push_back"), method_2598, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2599, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1627, type_1627, type_2557), Reflex::Literal("insert"), method_2600, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1627, type_1218, type_2557), Reflex::Literal("insert"), method_2601, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1627, type_1627), Reflex::Literal("erase"), method_2602, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1627, type_1627, type_1627), Reflex::Literal("erase"), method_2603, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5964), Reflex::Literal("swap"), method_2604, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_2605, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<JetParticleAssociation,std::allocator<JetParticleAssociation> > -------------------------------
static void constructor_2632( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetParticleAssociation>();
  else ::new(mem) ::std::vector<JetParticleAssociation>();
}

static void constructor_2633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetParticleAssociation>(*(const ::std::allocator<JetParticleAssociation>*)arg[0]);
  else ::new(mem) ::std::vector<JetParticleAssociation>(*(const ::std::allocator<JetParticleAssociation>*)arg[0]);
}

static void constructor_2634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetParticleAssociation>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<JetParticleAssociation>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::JetParticleAssociation*)arg[1]);
  else ::new(mem) ::std::vector<JetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::JetParticleAssociation*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::JetParticleAssociation*)arg[1],
      *(const ::std::allocator<JetParticleAssociation>*)arg[2]);
  else ::new(mem) ::std::vector<JetParticleAssociation>(*(::std::size_t*)arg[0],
      *(const ::JetParticleAssociation*)arg[1],
      *(const ::std::allocator<JetParticleAssociation>*)arg[2]);
  }
}

static void constructor_2635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<JetParticleAssociation>(*(const ::std::vector<JetParticleAssociation>*)arg[0]);
  else ::new(mem) ::std::vector<JetParticleAssociation>(*(const ::std::vector<JetParticleAssociation>*)arg[0]);
}

static void destructor_2636(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<JetParticleAssociation>*)o)->::std::vector<JetParticleAssociation>::~vector)();
}
static  void operator_2637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetParticleAssociation>*)o)->operator=)(*(const ::std::vector<JetParticleAssociation>*)arg[0]);
  else   (((::std::vector<JetParticleAssociation>*)o)->operator=)(*(const ::std::vector<JetParticleAssociation>*)arg[0]);
}

static  void method_2638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::JetParticleAssociation*)arg[1]);
}

static  void method_2639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((::std::vector<JetParticleAssociation>*)o)->begin)());
  else   (((::std::vector<JetParticleAssociation>*)o)->begin)();
}

static  void method_2640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((const ::std::vector<JetParticleAssociation>*)o)->begin)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->begin)();
}

static  void method_2641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((::std::vector<JetParticleAssociation>*)o)->end)());
  else   (((::std::vector<JetParticleAssociation>*)o)->end)();
}

static  void method_2642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((const ::std::vector<JetParticleAssociation>*)o)->end)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->end)();
}

static  void method_2647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JetParticleAssociation>*)o)->size)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->size)();
}

static  void method_2648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JetParticleAssociation>*)o)->max_size)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->max_size)();
}

static  void method_2649( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<JetParticleAssociation>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<JetParticleAssociation>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::JetParticleAssociation*)arg[1]);
  }
}

static  void method_2650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<JetParticleAssociation>*)o)->capacity)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->capacity)();
}

static  void method_2651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<JetParticleAssociation>*)o)->empty)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->empty)();
}

static  void method_2652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<JetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<JetParticleAssociation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<JetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<JetParticleAssociation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetParticleAssociation>*)o)->front)();
  else   (((::std::vector<JetParticleAssociation>*)o)->front)();
}

static  void method_2659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetParticleAssociation>*)o)->front)();
  else   (((const ::std::vector<JetParticleAssociation>*)o)->front)();
}

static  void method_2660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<JetParticleAssociation>*)o)->back)();
  else   (((::std::vector<JetParticleAssociation>*)o)->back)();
}

static  void method_2661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<JetParticleAssociation>*)o)->back)();
  else   (((const ::std::vector<JetParticleAssociation>*)o)->back)();
}

static  void method_2662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<JetParticleAssociation>*)o)->data)());
  else   (((::std::vector<JetParticleAssociation>*)o)->data)();
}

static  void method_2663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<JetParticleAssociation>*)o)->data)());
  else   (((const ::std::vector<JetParticleAssociation>*)o)->data)();
}

static  void method_2664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->push_back)(*(const ::JetParticleAssociation*)arg[0]);
}

static  void method_2665( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->pop_back)();
}

static  void method_2666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((::std::vector<JetParticleAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0],
    *(const ::JetParticleAssociation*)arg[1]));
  else   (((::std::vector<JetParticleAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0],
    *(const ::JetParticleAssociation*)arg[1]);
}

static  void method_2667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::JetParticleAssociation*)arg[2]);
}

static  void method_2668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((::std::vector<JetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0]));
  else   (((::std::vector<JetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0]);
}

static  void method_2669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >)((((::std::vector<JetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[1]));
  else   (((::std::vector<JetParticleAssociation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<JetParticleAssociation*,std::vector<JetParticleAssociation> >*)arg[1]);
}

static  void method_2670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->swap)(*(::std::vector<JetParticleAssociation>*)arg[0]);
}

static  void method_2671( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<JetParticleAssociation>*)o)->clear)();
}

static void method_newdel_1027( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<JetParticleAssociation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<JetParticleAssociation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<JetParticleAssociation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<JetParticleAssociation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<JetParticleAssociation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<JetParticleAssociation,std::allocator<JetParticleAssociation> >")), ::Reflex::BaseOffset< ::std::vector<JetParticleAssociation>,::std::_Vector_base<JetParticleAssociation,std::allocator<JetParticleAssociation> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<JetParticleAssociation> >::Generate();
  else ::Reflex::Proxy< ::std::vector<JetParticleAssociation> >::Generate();
}

//------Dictionary for class vector<JetParticleAssociation,std::allocator<JetParticleAssociation> > -------------------------------
void __std__vector_JetParticleAssociation__db_datamem(Reflex::Class*);
void __std__vector_JetParticleAssociation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_JetParticleAssociation__datamem_bld(&__std__vector_JetParticleAssociation__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_JetParticleAssociation__funcmem_bld(&__std__vector_JetParticleAssociation__db_funcmem);
void __std__vector_JetParticleAssociation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<JetParticleAssociation>"), typeid(::std::vector<JetParticleAssociation>), sizeof(::std::vector<JetParticleAssociation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1252, ::Reflex::BaseOffset< ::std::vector<JetParticleAssociation>, ::std::_Vector_base<JetParticleAssociation,std::allocator<JetParticleAssociation> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_529, Reflex::Literal("std::vector<JetParticleAssociation>::_Alloc_value_type"))
  .AddTypedef(type_1252, Reflex::Literal("std::vector<JetParticleAssociation>::_Base"))
  .AddTypedef(type_1140, Reflex::Literal("std::vector<JetParticleAssociation>::_Tp_alloc_type"))
  .AddTypedef(type_1556, Reflex::Literal("std::vector<JetParticleAssociation>::_Alloc_traits"))
  .AddTypedef(type_529, Reflex::Literal("std::vector<JetParticleAssociation>::value_type"))
  .AddTypedef(type_2617, Reflex::Literal("std::vector<JetParticleAssociation>::pointer"))
  .AddTypedef(type_2619, Reflex::Literal("std::vector<JetParticleAssociation>::const_pointer"))
  .AddTypedef(type_2621, Reflex::Literal("std::vector<JetParticleAssociation>::reference"))
  .AddTypedef(type_2623, Reflex::Literal("std::vector<JetParticleAssociation>::const_reference"))
  .AddTypedef(type_1631, Reflex::Literal("std::vector<JetParticleAssociation>::iterator"))
  .AddTypedef(type_1632, Reflex::Literal("std::vector<JetParticleAssociation>::const_iterator"))
  .AddTypedef(type_1227, Reflex::Literal("std::vector<JetParticleAssociation>::const_reverse_iterator"))
  .AddTypedef(type_1228, Reflex::Literal("std::vector<JetParticleAssociation>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<JetParticleAssociation>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<JetParticleAssociation>::difference_type"))
  .AddTypedef(type_1140, Reflex::Literal("std::vector<JetParticleAssociation>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2632, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5966), Reflex::Literal("vector"), constructor_2633, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2623, type_5966), Reflex::Literal("vector"), constructor_2634, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5967), Reflex::Literal("vector"), constructor_2635, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2636, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1027, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_JetParticleAssociation__funcmem_bld);
}

//------Delayed data member builder for class vector<JetParticleAssociation,std::allocator<JetParticleAssociation> > -------------------
void __std__vector_JetParticleAssociation__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<JetParticleAssociation,std::allocator<JetParticleAssociation> > -------------------
void __std__vector_JetParticleAssociation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5968, type_5967), Reflex::Literal("operator="), operator_2637, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2623), Reflex::Literal("assign"), method_2638, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1631), Reflex::Literal("begin"), method_2639, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1632), Reflex::Literal("begin"), method_2640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1631), Reflex::Literal("end"), method_2641, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1632), Reflex::Literal("end"), method_2642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_529), Reflex::Literal("resize"), method_2649, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2652, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2621, type_1218), Reflex::Literal("operator[]"), operator_2653, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2623, type_1218), Reflex::Literal("operator[]"), operator_2654, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2621, type_1218), Reflex::Literal("at"), method_2656, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2623, type_1218), Reflex::Literal("at"), method_2657, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2621), Reflex::Literal("front"), method_2658, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2623), Reflex::Literal("front"), method_2659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2621), Reflex::Literal("back"), method_2660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2623), Reflex::Literal("back"), method_2661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2617), Reflex::Literal("data"), method_2662, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2619), Reflex::Literal("data"), method_2663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2623), Reflex::Literal("push_back"), method_2664, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2665, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1631, type_1631, type_2623), Reflex::Literal("insert"), method_2666, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1631, type_1218, type_2623), Reflex::Literal("insert"), method_2667, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1631, type_1631), Reflex::Literal("erase"), method_2668, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1631, type_1631, type_1631), Reflex::Literal("erase"), method_2669, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5968), Reflex::Literal("swap"), method_2670, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_2671, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<MCParticle,std::allocator<MCParticle> > -------------------------------
static void constructor_2698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<MCParticle>();
  else ::new(mem) ::std::vector<MCParticle>();
}

static void constructor_2699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<MCParticle>(*(const ::std::allocator<MCParticle>*)arg[0]);
  else ::new(mem) ::std::vector<MCParticle>(*(const ::std::allocator<MCParticle>*)arg[0]);
}

static void constructor_2700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<MCParticle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<MCParticle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<MCParticle>(*(::std::size_t*)arg[0],
      *(const ::MCParticle*)arg[1]);
  else ::new(mem) ::std::vector<MCParticle>(*(::std::size_t*)arg[0],
      *(const ::MCParticle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<MCParticle>(*(::std::size_t*)arg[0],
      *(const ::MCParticle*)arg[1],
      *(const ::std::allocator<MCParticle>*)arg[2]);
  else ::new(mem) ::std::vector<MCParticle>(*(::std::size_t*)arg[0],
      *(const ::MCParticle*)arg[1],
      *(const ::std::allocator<MCParticle>*)arg[2]);
  }
}

static void constructor_2701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<MCParticle>(*(const ::std::vector<MCParticle>*)arg[0]);
  else ::new(mem) ::std::vector<MCParticle>(*(const ::std::vector<MCParticle>*)arg[0]);
}

static void destructor_2702(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<MCParticle>*)o)->::std::vector<MCParticle>::~vector)();
}
static  void operator_2703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<MCParticle>*)o)->operator=)(*(const ::std::vector<MCParticle>*)arg[0]);
  else   (((::std::vector<MCParticle>*)o)->operator=)(*(const ::std::vector<MCParticle>*)arg[0]);
}

static  void method_2704( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<MCParticle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::MCParticle*)arg[1]);
}

static  void method_2705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >)((((::std::vector<MCParticle>*)o)->begin)());
  else   (((::std::vector<MCParticle>*)o)->begin)();
}

static  void method_2706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const MCParticle*,std::vector<MCParticle> >)((((const ::std::vector<MCParticle>*)o)->begin)());
  else   (((const ::std::vector<MCParticle>*)o)->begin)();
}

static  void method_2707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >)((((::std::vector<MCParticle>*)o)->end)());
  else   (((::std::vector<MCParticle>*)o)->end)();
}

static  void method_2708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const MCParticle*,std::vector<MCParticle> >)((((const ::std::vector<MCParticle>*)o)->end)());
  else   (((const ::std::vector<MCParticle>*)o)->end)();
}

static  void method_2713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<MCParticle>*)o)->size)());
  else   (((const ::std::vector<MCParticle>*)o)->size)();
}

static  void method_2714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<MCParticle>*)o)->max_size)());
  else   (((const ::std::vector<MCParticle>*)o)->max_size)();
}

static  void method_2715( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<MCParticle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<MCParticle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::MCParticle*)arg[1]);
  }
}

static  void method_2716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<MCParticle>*)o)->capacity)());
  else   (((const ::std::vector<MCParticle>*)o)->capacity)();
}

static  void method_2717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<MCParticle>*)o)->empty)());
  else   (((const ::std::vector<MCParticle>*)o)->empty)();
}

static  void method_2718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<MCParticle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<MCParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<MCParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<MCParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<MCParticle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<MCParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<MCParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<MCParticle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<MCParticle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<MCParticle>*)o)->front)();
  else   (((::std::vector<MCParticle>*)o)->front)();
}

static  void method_2725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<MCParticle>*)o)->front)();
  else   (((const ::std::vector<MCParticle>*)o)->front)();
}

static  void method_2726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<MCParticle>*)o)->back)();
  else   (((::std::vector<MCParticle>*)o)->back)();
}

static  void method_2727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<MCParticle>*)o)->back)();
  else   (((const ::std::vector<MCParticle>*)o)->back)();
}

static  void method_2728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<MCParticle>*)o)->data)());
  else   (((::std::vector<MCParticle>*)o)->data)();
}

static  void method_2729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<MCParticle>*)o)->data)());
  else   (((const ::std::vector<MCParticle>*)o)->data)();
}

static  void method_2730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<MCParticle>*)o)->push_back)(*(const ::MCParticle*)arg[0]);
}

static  void method_2731( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<MCParticle>*)o)->pop_back)();
}

static  void method_2732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >)((((::std::vector<MCParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0],
    *(const ::MCParticle*)arg[1]));
  else   (((::std::vector<MCParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0],
    *(const ::MCParticle*)arg[1]);
}

static  void method_2733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<MCParticle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::MCParticle*)arg[2]);
}

static  void method_2734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >)((((::std::vector<MCParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0]));
  else   (((::std::vector<MCParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0]);
}

static  void method_2735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >)((((::std::vector<MCParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[1]));
  else   (((::std::vector<MCParticle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<MCParticle*,std::vector<MCParticle> >*)arg[1]);
}

static  void method_2736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<MCParticle>*)o)->swap)(*(::std::vector<MCParticle>*)arg[0]);
}

static  void method_2737( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<MCParticle>*)o)->clear)();
}

static void method_newdel_1028( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<MCParticle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<MCParticle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<MCParticle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<MCParticle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<MCParticle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<MCParticle,std::allocator<MCParticle> >")), ::Reflex::BaseOffset< ::std::vector<MCParticle>,::std::_Vector_base<MCParticle,std::allocator<MCParticle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x28( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<MCParticle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<MCParticle> >::Generate();
}

//------Dictionary for class vector<MCParticle,std::allocator<MCParticle> > -------------------------------
void __std__vector_MCParticle__db_datamem(Reflex::Class*);
void __std__vector_MCParticle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_MCParticle__datamem_bld(&__std__vector_MCParticle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_MCParticle__funcmem_bld(&__std__vector_MCParticle__db_funcmem);
void __std__vector_MCParticle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<MCParticle>"), typeid(::std::vector<MCParticle>), sizeof(::std::vector<MCParticle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1253, ::Reflex::BaseOffset< ::std::vector<MCParticle>, ::std::_Vector_base<MCParticle,std::allocator<MCParticle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_119, Reflex::Literal("std::vector<MCParticle>::_Alloc_value_type"))
  .AddTypedef(type_1253, Reflex::Literal("std::vector<MCParticle>::_Base"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<MCParticle>::_Tp_alloc_type"))
  .AddTypedef(type_1557, Reflex::Literal("std::vector<MCParticle>::_Alloc_traits"))
  .AddTypedef(type_119, Reflex::Literal("std::vector<MCParticle>::value_type"))
  .AddTypedef(type_2683, Reflex::Literal("std::vector<MCParticle>::pointer"))
  .AddTypedef(type_2685, Reflex::Literal("std::vector<MCParticle>::const_pointer"))
  .AddTypedef(type_2687, Reflex::Literal("std::vector<MCParticle>::reference"))
  .AddTypedef(type_2689, Reflex::Literal("std::vector<MCParticle>::const_reference"))
  .AddTypedef(type_1633, Reflex::Literal("std::vector<MCParticle>::iterator"))
  .AddTypedef(type_1634, Reflex::Literal("std::vector<MCParticle>::const_iterator"))
  .AddTypedef(type_1229, Reflex::Literal("std::vector<MCParticle>::const_reverse_iterator"))
  .AddTypedef(type_1230, Reflex::Literal("std::vector<MCParticle>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<MCParticle>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<MCParticle>::difference_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::vector<MCParticle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2698, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5970), Reflex::Literal("vector"), constructor_2699, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2689, type_5970), Reflex::Literal("vector"), constructor_2700, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5971), Reflex::Literal("vector"), constructor_2701, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2702, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1028, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x28, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_MCParticle__funcmem_bld);
}

//------Delayed data member builder for class vector<MCParticle,std::allocator<MCParticle> > -------------------
void __std__vector_MCParticle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<MCParticle,std::allocator<MCParticle> > -------------------
void __std__vector_MCParticle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5972, type_5971), Reflex::Literal("operator="), operator_2703, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2689), Reflex::Literal("assign"), method_2704, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1633), Reflex::Literal("begin"), method_2705, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1634), Reflex::Literal("begin"), method_2706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1633), Reflex::Literal("end"), method_2707, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1634), Reflex::Literal("end"), method_2708, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_119), Reflex::Literal("resize"), method_2715, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2718, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_1218), Reflex::Literal("operator[]"), operator_2719, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2689, type_1218), Reflex::Literal("operator[]"), operator_2720, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687, type_1218), Reflex::Literal("at"), method_2722, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2689, type_1218), Reflex::Literal("at"), method_2723, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("front"), method_2724, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2689), Reflex::Literal("front"), method_2725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2687), Reflex::Literal("back"), method_2726, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2689), Reflex::Literal("back"), method_2727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2683), Reflex::Literal("data"), method_2728, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2685), Reflex::Literal("data"), method_2729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2689), Reflex::Literal("push_back"), method_2730, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1633, type_1633, type_2689), Reflex::Literal("insert"), method_2732, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1633, type_1218, type_2689), Reflex::Literal("insert"), method_2733, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1633, type_1633), Reflex::Literal("erase"), method_2734, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1633, type_1633, type_1633), Reflex::Literal("erase"), method_2735, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5972), Reflex::Literal("swap"), method_2736, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_2737, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<Particle,std::allocator<Particle> > -------------------------------
static void constructor_2764( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Particle>();
  else ::new(mem) ::std::vector<Particle>();
}

static void constructor_2765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Particle>(*(const ::std::allocator<Particle>*)arg[0]);
  else ::new(mem) ::std::vector<Particle>(*(const ::std::allocator<Particle>*)arg[0]);
}

static void constructor_2766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Particle>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Particle>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Particle>(*(::std::size_t*)arg[0],
      *(const ::Particle*)arg[1]);
  else ::new(mem) ::std::vector<Particle>(*(::std::size_t*)arg[0],
      *(const ::Particle*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Particle>(*(::std::size_t*)arg[0],
      *(const ::Particle*)arg[1],
      *(const ::std::allocator<Particle>*)arg[2]);
  else ::new(mem) ::std::vector<Particle>(*(::std::size_t*)arg[0],
      *(const ::Particle*)arg[1],
      *(const ::std::allocator<Particle>*)arg[2]);
  }
}

static void constructor_2767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Particle>(*(const ::std::vector<Particle>*)arg[0]);
  else ::new(mem) ::std::vector<Particle>(*(const ::std::vector<Particle>*)arg[0]);
}

static void destructor_2768(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Particle>*)o)->::std::vector<Particle>::~vector)();
}
static  void operator_2769( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Particle>*)o)->operator=)(*(const ::std::vector<Particle>*)arg[0]);
  else   (((::std::vector<Particle>*)o)->operator=)(*(const ::std::vector<Particle>*)arg[0]);
}

static  void method_2770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Particle>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::Particle*)arg[1]);
}

static  void method_2771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >)((((::std::vector<Particle>*)o)->begin)());
  else   (((::std::vector<Particle>*)o)->begin)();
}

static  void method_2772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Particle*,std::vector<Particle> >)((((const ::std::vector<Particle>*)o)->begin)());
  else   (((const ::std::vector<Particle>*)o)->begin)();
}

static  void method_2773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >)((((::std::vector<Particle>*)o)->end)());
  else   (((::std::vector<Particle>*)o)->end)();
}

static  void method_2774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Particle*,std::vector<Particle> >)((((const ::std::vector<Particle>*)o)->end)());
  else   (((const ::std::vector<Particle>*)o)->end)();
}

static  void method_2779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Particle>*)o)->size)());
  else   (((const ::std::vector<Particle>*)o)->size)();
}

static  void method_2780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Particle>*)o)->max_size)());
  else   (((const ::std::vector<Particle>*)o)->max_size)();
}

static  void method_2781( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Particle>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Particle>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::Particle*)arg[1]);
  }
}

static  void method_2782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Particle>*)o)->capacity)());
  else   (((const ::std::vector<Particle>*)o)->capacity)();
}

static  void method_2783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Particle>*)o)->empty)());
  else   (((const ::std::vector<Particle>*)o)->empty)();
}

static  void method_2784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Particle>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2786( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Particle>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Particle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Particle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Particle>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Particle>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Particle>*)o)->front)();
  else   (((::std::vector<Particle>*)o)->front)();
}

static  void method_2791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Particle>*)o)->front)();
  else   (((const ::std::vector<Particle>*)o)->front)();
}

static  void method_2792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Particle>*)o)->back)();
  else   (((::std::vector<Particle>*)o)->back)();
}

static  void method_2793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Particle>*)o)->back)();
  else   (((const ::std::vector<Particle>*)o)->back)();
}

static  void method_2794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Particle>*)o)->data)());
  else   (((::std::vector<Particle>*)o)->data)();
}

static  void method_2795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Particle>*)o)->data)());
  else   (((const ::std::vector<Particle>*)o)->data)();
}

static  void method_2796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Particle>*)o)->push_back)(*(const ::Particle*)arg[0]);
}

static  void method_2797( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Particle>*)o)->pop_back)();
}

static  void method_2798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >)((((::std::vector<Particle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0],
    *(const ::Particle*)arg[1]));
  else   (((::std::vector<Particle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0],
    *(const ::Particle*)arg[1]);
}

static  void method_2799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Particle>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::Particle*)arg[2]);
}

static  void method_2800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >)((((::std::vector<Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0]));
  else   (((::std::vector<Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0]);
}

static  void method_2801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >)((((::std::vector<Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[1]));
  else   (((::std::vector<Particle>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Particle*,std::vector<Particle> >*)arg[1]);
}

static  void method_2802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Particle>*)o)->swap)(*(::std::vector<Particle>*)arg[0]);
}

static  void method_2803( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Particle>*)o)->clear)();
}

static void method_newdel_1029( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Particle> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Particle> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Particle> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Particle> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Particle> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Particle,std::allocator<Particle> >")), ::Reflex::BaseOffset< ::std::vector<Particle>,::std::_Vector_base<Particle,std::allocator<Particle> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x31( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Particle> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Particle> >::Generate();
}

//------Dictionary for class vector<Particle,std::allocator<Particle> > -------------------------------
void __std__vector_Particle__db_datamem(Reflex::Class*);
void __std__vector_Particle__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Particle__datamem_bld(&__std__vector_Particle__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Particle__funcmem_bld(&__std__vector_Particle__db_funcmem);
void __std__vector_Particle__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Particle>"), typeid(::std::vector<Particle>), sizeof(::std::vector<Particle>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1254, ::Reflex::BaseOffset< ::std::vector<Particle>, ::std::_Vector_base<Particle,std::allocator<Particle> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_77, Reflex::Literal("std::vector<Particle>::_Alloc_value_type"))
  .AddTypedef(type_1254, Reflex::Literal("std::vector<Particle>::_Base"))
  .AddTypedef(type_1142, Reflex::Literal("std::vector<Particle>::_Tp_alloc_type"))
  .AddTypedef(type_1558, Reflex::Literal("std::vector<Particle>::_Alloc_traits"))
  .AddTypedef(type_77, Reflex::Literal("std::vector<Particle>::value_type"))
  .AddTypedef(type_2749, Reflex::Literal("std::vector<Particle>::pointer"))
  .AddTypedef(type_2751, Reflex::Literal("std::vector<Particle>::const_pointer"))
  .AddTypedef(type_2753, Reflex::Literal("std::vector<Particle>::reference"))
  .AddTypedef(type_2755, Reflex::Literal("std::vector<Particle>::const_reference"))
  .AddTypedef(type_1635, Reflex::Literal("std::vector<Particle>::iterator"))
  .AddTypedef(type_1636, Reflex::Literal("std::vector<Particle>::const_iterator"))
  .AddTypedef(type_1231, Reflex::Literal("std::vector<Particle>::const_reverse_iterator"))
  .AddTypedef(type_1232, Reflex::Literal("std::vector<Particle>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<Particle>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<Particle>::difference_type"))
  .AddTypedef(type_1142, Reflex::Literal("std::vector<Particle>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2764, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5974), Reflex::Literal("vector"), constructor_2765, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2755, type_5974), Reflex::Literal("vector"), constructor_2766, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5975), Reflex::Literal("vector"), constructor_2767, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2768, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1029, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x31, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Particle__funcmem_bld);
}

//------Delayed data member builder for class vector<Particle,std::allocator<Particle> > -------------------
void __std__vector_Particle__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Particle,std::allocator<Particle> > -------------------
void __std__vector_Particle__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5976, type_5975), Reflex::Literal("operator="), operator_2769, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2755), Reflex::Literal("assign"), method_2770, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1635), Reflex::Literal("begin"), method_2771, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("begin"), method_2772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1635), Reflex::Literal("end"), method_2773, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1636), Reflex::Literal("end"), method_2774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_77), Reflex::Literal("resize"), method_2781, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2784, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_1218), Reflex::Literal("operator[]"), operator_2785, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755, type_1218), Reflex::Literal("operator[]"), operator_2786, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753, type_1218), Reflex::Literal("at"), method_2788, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755, type_1218), Reflex::Literal("at"), method_2789, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753), Reflex::Literal("front"), method_2790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("front"), method_2791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2753), Reflex::Literal("back"), method_2792, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2755), Reflex::Literal("back"), method_2793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2749), Reflex::Literal("data"), method_2794, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2751), Reflex::Literal("data"), method_2795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2755), Reflex::Literal("push_back"), method_2796, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2797, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1635, type_1635, type_2755), Reflex::Literal("insert"), method_2798, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1635, type_1218, type_2755), Reflex::Literal("insert"), method_2799, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1635, type_1635), Reflex::Literal("erase"), method_2800, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1635, type_1635, type_1635), Reflex::Literal("erase"), method_2801, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5976), Reflex::Literal("swap"), method_2802, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_2803, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<EventInfo,std::allocator<EventInfo> > -------------------------------
static void constructor_2830( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<EventInfo>();
  else ::new(mem) ::std::vector<EventInfo>();
}

static void constructor_2831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<EventInfo>(*(const ::std::allocator<EventInfo>*)arg[0]);
  else ::new(mem) ::std::vector<EventInfo>(*(const ::std::allocator<EventInfo>*)arg[0]);
}

static void constructor_2832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<EventInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<EventInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<EventInfo>(*(::std::size_t*)arg[0],
      *(const ::EventInfo*)arg[1]);
  else ::new(mem) ::std::vector<EventInfo>(*(::std::size_t*)arg[0],
      *(const ::EventInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<EventInfo>(*(::std::size_t*)arg[0],
      *(const ::EventInfo*)arg[1],
      *(const ::std::allocator<EventInfo>*)arg[2]);
  else ::new(mem) ::std::vector<EventInfo>(*(::std::size_t*)arg[0],
      *(const ::EventInfo*)arg[1],
      *(const ::std::allocator<EventInfo>*)arg[2]);
  }
}

static void constructor_2833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<EventInfo>(*(const ::std::vector<EventInfo>*)arg[0]);
  else ::new(mem) ::std::vector<EventInfo>(*(const ::std::vector<EventInfo>*)arg[0]);
}

static void destructor_2834(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<EventInfo>*)o)->::std::vector<EventInfo>::~vector)();
}
static  void operator_2835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<EventInfo>*)o)->operator=)(*(const ::std::vector<EventInfo>*)arg[0]);
  else   (((::std::vector<EventInfo>*)o)->operator=)(*(const ::std::vector<EventInfo>*)arg[0]);
}

static  void method_2836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<EventInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::EventInfo*)arg[1]);
}

static  void method_2837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >)((((::std::vector<EventInfo>*)o)->begin)());
  else   (((::std::vector<EventInfo>*)o)->begin)();
}

static  void method_2838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const EventInfo*,std::vector<EventInfo> >)((((const ::std::vector<EventInfo>*)o)->begin)());
  else   (((const ::std::vector<EventInfo>*)o)->begin)();
}

static  void method_2839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >)((((::std::vector<EventInfo>*)o)->end)());
  else   (((::std::vector<EventInfo>*)o)->end)();
}

static  void method_2840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const EventInfo*,std::vector<EventInfo> >)((((const ::std::vector<EventInfo>*)o)->end)());
  else   (((const ::std::vector<EventInfo>*)o)->end)();
}

static  void method_2845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<EventInfo>*)o)->size)());
  else   (((const ::std::vector<EventInfo>*)o)->size)();
}

static  void method_2846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<EventInfo>*)o)->max_size)());
  else   (((const ::std::vector<EventInfo>*)o)->max_size)();
}

static  void method_2847( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<EventInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<EventInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::EventInfo*)arg[1]);
  }
}

static  void method_2848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<EventInfo>*)o)->capacity)());
  else   (((const ::std::vector<EventInfo>*)o)->capacity)();
}

static  void method_2849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<EventInfo>*)o)->empty)());
  else   (((const ::std::vector<EventInfo>*)o)->empty)();
}

static  void method_2850( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<EventInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<EventInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<EventInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<EventInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<EventInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2854( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<EventInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<EventInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<EventInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<EventInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<EventInfo>*)o)->front)();
  else   (((::std::vector<EventInfo>*)o)->front)();
}

static  void method_2857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<EventInfo>*)o)->front)();
  else   (((const ::std::vector<EventInfo>*)o)->front)();
}

static  void method_2858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<EventInfo>*)o)->back)();
  else   (((::std::vector<EventInfo>*)o)->back)();
}

static  void method_2859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<EventInfo>*)o)->back)();
  else   (((const ::std::vector<EventInfo>*)o)->back)();
}

static  void method_2860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<EventInfo>*)o)->data)());
  else   (((::std::vector<EventInfo>*)o)->data)();
}

static  void method_2861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<EventInfo>*)o)->data)());
  else   (((const ::std::vector<EventInfo>*)o)->data)();
}

static  void method_2862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<EventInfo>*)o)->push_back)(*(const ::EventInfo*)arg[0]);
}

static  void method_2863( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<EventInfo>*)o)->pop_back)();
}

static  void method_2864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >)((((::std::vector<EventInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0],
    *(const ::EventInfo*)arg[1]));
  else   (((::std::vector<EventInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0],
    *(const ::EventInfo*)arg[1]);
}

static  void method_2865( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<EventInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::EventInfo*)arg[2]);
}

static  void method_2866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >)((((::std::vector<EventInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0]));
  else   (((::std::vector<EventInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0]);
}

static  void method_2867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >)((((::std::vector<EventInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[1]));
  else   (((::std::vector<EventInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<EventInfo*,std::vector<EventInfo> >*)arg[1]);
}

static  void method_2868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<EventInfo>*)o)->swap)(*(::std::vector<EventInfo>*)arg[0]);
}

static  void method_2869( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<EventInfo>*)o)->clear)();
}

static void method_newdel_1030( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<EventInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<EventInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<EventInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<EventInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<EventInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<EventInfo,std::allocator<EventInfo> >")), ::Reflex::BaseOffset< ::std::vector<EventInfo>,::std::_Vector_base<EventInfo,std::allocator<EventInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<EventInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<EventInfo> >::Generate();
}

//------Dictionary for class vector<EventInfo,std::allocator<EventInfo> > -------------------------------
void __std__vector_EventInfo__db_datamem(Reflex::Class*);
void __std__vector_EventInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_EventInfo__datamem_bld(&__std__vector_EventInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_EventInfo__funcmem_bld(&__std__vector_EventInfo__db_funcmem);
void __std__vector_EventInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<EventInfo>"), typeid(::std::vector<EventInfo>), sizeof(::std::vector<EventInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1249, ::Reflex::BaseOffset< ::std::vector<EventInfo>, ::std::_Vector_base<EventInfo,std::allocator<EventInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_779, Reflex::Literal("std::vector<EventInfo>::_Alloc_value_type"))
  .AddTypedef(type_1249, Reflex::Literal("std::vector<EventInfo>::_Base"))
  .AddTypedef(type_1143, Reflex::Literal("std::vector<EventInfo>::_Tp_alloc_type"))
  .AddTypedef(type_1553, Reflex::Literal("std::vector<EventInfo>::_Alloc_traits"))
  .AddTypedef(type_779, Reflex::Literal("std::vector<EventInfo>::value_type"))
  .AddTypedef(type_2815, Reflex::Literal("std::vector<EventInfo>::pointer"))
  .AddTypedef(type_2817, Reflex::Literal("std::vector<EventInfo>::const_pointer"))
  .AddTypedef(type_2819, Reflex::Literal("std::vector<EventInfo>::reference"))
  .AddTypedef(type_2821, Reflex::Literal("std::vector<EventInfo>::const_reference"))
  .AddTypedef(type_1625, Reflex::Literal("std::vector<EventInfo>::iterator"))
  .AddTypedef(type_1626, Reflex::Literal("std::vector<EventInfo>::const_iterator"))
  .AddTypedef(type_1221, Reflex::Literal("std::vector<EventInfo>::const_reverse_iterator"))
  .AddTypedef(type_1222, Reflex::Literal("std::vector<EventInfo>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<EventInfo>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<EventInfo>::difference_type"))
  .AddTypedef(type_1143, Reflex::Literal("std::vector<EventInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2830, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5978), Reflex::Literal("vector"), constructor_2831, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2821, type_5978), Reflex::Literal("vector"), constructor_2832, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5979), Reflex::Literal("vector"), constructor_2833, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2834, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1030, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_EventInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<EventInfo,std::allocator<EventInfo> > -------------------
void __std__vector_EventInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<EventInfo,std::allocator<EventInfo> > -------------------
void __std__vector_EventInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5980, type_5979), Reflex::Literal("operator="), operator_2835, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2821), Reflex::Literal("assign"), method_2836, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1625), Reflex::Literal("begin"), method_2837, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1626), Reflex::Literal("begin"), method_2838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1625), Reflex::Literal("end"), method_2839, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1626), Reflex::Literal("end"), method_2840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_779), Reflex::Literal("resize"), method_2847, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2848, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2850, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_1218), Reflex::Literal("operator[]"), operator_2851, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2821, type_1218), Reflex::Literal("operator[]"), operator_2852, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819, type_1218), Reflex::Literal("at"), method_2854, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2821, type_1218), Reflex::Literal("at"), method_2855, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("front"), method_2856, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2821), Reflex::Literal("front"), method_2857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2819), Reflex::Literal("back"), method_2858, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2821), Reflex::Literal("back"), method_2859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2815), Reflex::Literal("data"), method_2860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2817), Reflex::Literal("data"), method_2861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2821), Reflex::Literal("push_back"), method_2862, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2863, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1625, type_1625, type_2821), Reflex::Literal("insert"), method_2864, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1625, type_1218, type_2821), Reflex::Literal("insert"), method_2865, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1625, type_1625), Reflex::Literal("erase"), method_2866, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1625, type_1625, type_1625), Reflex::Literal("erase"), method_2867, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5980), Reflex::Literal("swap"), method_2868, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_2869, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<GenJet,std::allocator<GenJet> > -------------------------------
static void constructor_2896( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJet>();
  else ::new(mem) ::std::vector<GenJet>();
}

static void constructor_2897( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJet>(*(const ::std::allocator<GenJet>*)arg[0]);
  else ::new(mem) ::std::vector<GenJet>(*(const ::std::allocator<GenJet>*)arg[0]);
}

static void constructor_2898( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<GenJet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJet>(*(::std::size_t*)arg[0],
      *(const ::GenJet*)arg[1]);
  else ::new(mem) ::std::vector<GenJet>(*(::std::size_t*)arg[0],
      *(const ::GenJet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJet>(*(::std::size_t*)arg[0],
      *(const ::GenJet*)arg[1],
      *(const ::std::allocator<GenJet>*)arg[2]);
  else ::new(mem) ::std::vector<GenJet>(*(::std::size_t*)arg[0],
      *(const ::GenJet*)arg[1],
      *(const ::std::allocator<GenJet>*)arg[2]);
  }
}

static void constructor_2899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GenJet>(*(const ::std::vector<GenJet>*)arg[0]);
  else ::new(mem) ::std::vector<GenJet>(*(const ::std::vector<GenJet>*)arg[0]);
}

static void destructor_2900(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<GenJet>*)o)->::std::vector<GenJet>::~vector)();
}
static  void operator_2901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJet>*)o)->operator=)(*(const ::std::vector<GenJet>*)arg[0]);
  else   (((::std::vector<GenJet>*)o)->operator=)(*(const ::std::vector<GenJet>*)arg[0]);
}

static  void method_2902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::GenJet*)arg[1]);
}

static  void method_2903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >)((((::std::vector<GenJet>*)o)->begin)());
  else   (((::std::vector<GenJet>*)o)->begin)();
}

static  void method_2904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenJet*,std::vector<GenJet> >)((((const ::std::vector<GenJet>*)o)->begin)());
  else   (((const ::std::vector<GenJet>*)o)->begin)();
}

static  void method_2905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >)((((::std::vector<GenJet>*)o)->end)());
  else   (((::std::vector<GenJet>*)o)->end)();
}

static  void method_2906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GenJet*,std::vector<GenJet> >)((((const ::std::vector<GenJet>*)o)->end)());
  else   (((const ::std::vector<GenJet>*)o)->end)();
}

static  void method_2911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenJet>*)o)->size)());
  else   (((const ::std::vector<GenJet>*)o)->size)();
}

static  void method_2912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenJet>*)o)->max_size)());
  else   (((const ::std::vector<GenJet>*)o)->max_size)();
}

static  void method_2913( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<GenJet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<GenJet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::GenJet*)arg[1]);
  }
}

static  void method_2914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GenJet>*)o)->capacity)());
  else   (((const ::std::vector<GenJet>*)o)->capacity)();
}

static  void method_2915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<GenJet>*)o)->empty)());
  else   (((const ::std::vector<GenJet>*)o)->empty)();
}

static  void method_2916( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenJet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenJet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GenJet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GenJet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJet>*)o)->front)();
  else   (((::std::vector<GenJet>*)o)->front)();
}

static  void method_2923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJet>*)o)->front)();
  else   (((const ::std::vector<GenJet>*)o)->front)();
}

static  void method_2924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GenJet>*)o)->back)();
  else   (((::std::vector<GenJet>*)o)->back)();
}

static  void method_2925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GenJet>*)o)->back)();
  else   (((const ::std::vector<GenJet>*)o)->back)();
}

static  void method_2926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<GenJet>*)o)->data)());
  else   (((::std::vector<GenJet>*)o)->data)();
}

static  void method_2927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<GenJet>*)o)->data)());
  else   (((const ::std::vector<GenJet>*)o)->data)();
}

static  void method_2928( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJet>*)o)->push_back)(*(const ::GenJet*)arg[0]);
}

static  void method_2929( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenJet>*)o)->pop_back)();
}

static  void method_2930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >)((((::std::vector<GenJet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0],
    *(const ::GenJet*)arg[1]));
  else   (((::std::vector<GenJet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0],
    *(const ::GenJet*)arg[1]);
}

static  void method_2931( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::GenJet*)arg[2]);
}

static  void method_2932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >)((((::std::vector<GenJet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0]));
  else   (((::std::vector<GenJet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0]);
}

static  void method_2933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >)((((::std::vector<GenJet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[1]));
  else   (((::std::vector<GenJet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GenJet*,std::vector<GenJet> >*)arg[1]);
}

static  void method_2934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GenJet>*)o)->swap)(*(::std::vector<GenJet>*)arg[0]);
}

static  void method_2935( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GenJet>*)o)->clear)();
}

static void method_newdel_1031( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<GenJet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<GenJet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<GenJet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<GenJet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<GenJet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GenJet,std::allocator<GenJet> >")), ::Reflex::BaseOffset< ::std::vector<GenJet>,::std::_Vector_base<GenJet,std::allocator<GenJet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x37( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<GenJet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<GenJet> >::Generate();
}

//------Dictionary for class vector<GenJet,std::allocator<GenJet> > -------------------------------
void __std__vector_GenJet__db_datamem(Reflex::Class*);
void __std__vector_GenJet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_GenJet__datamem_bld(&__std__vector_GenJet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_GenJet__funcmem_bld(&__std__vector_GenJet__db_funcmem);
void __std__vector_GenJet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<GenJet>"), typeid(::std::vector<GenJet>), sizeof(::std::vector<GenJet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1251, ::Reflex::BaseOffset< ::std::vector<GenJet>, ::std::_Vector_base<GenJet,std::allocator<GenJet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_6, Reflex::Literal("std::vector<GenJet>::_Alloc_value_type"))
  .AddTypedef(type_1251, Reflex::Literal("std::vector<GenJet>::_Base"))
  .AddTypedef(type_1144, Reflex::Literal("std::vector<GenJet>::_Tp_alloc_type"))
  .AddTypedef(type_1555, Reflex::Literal("std::vector<GenJet>::_Alloc_traits"))
  .AddTypedef(type_6, Reflex::Literal("std::vector<GenJet>::value_type"))
  .AddTypedef(type_2881, Reflex::Literal("std::vector<GenJet>::pointer"))
  .AddTypedef(type_2883, Reflex::Literal("std::vector<GenJet>::const_pointer"))
  .AddTypedef(type_2885, Reflex::Literal("std::vector<GenJet>::reference"))
  .AddTypedef(type_2887, Reflex::Literal("std::vector<GenJet>::const_reference"))
  .AddTypedef(type_1629, Reflex::Literal("std::vector<GenJet>::iterator"))
  .AddTypedef(type_1630, Reflex::Literal("std::vector<GenJet>::const_iterator"))
  .AddTypedef(type_1225, Reflex::Literal("std::vector<GenJet>::const_reverse_iterator"))
  .AddTypedef(type_1226, Reflex::Literal("std::vector<GenJet>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<GenJet>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<GenJet>::difference_type"))
  .AddTypedef(type_1144, Reflex::Literal("std::vector<GenJet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2896, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5982), Reflex::Literal("vector"), constructor_2897, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2887, type_5982), Reflex::Literal("vector"), constructor_2898, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5983), Reflex::Literal("vector"), constructor_2899, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2900, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1031, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x37, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_GenJet__funcmem_bld);
}

//------Delayed data member builder for class vector<GenJet,std::allocator<GenJet> > -------------------
void __std__vector_GenJet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<GenJet,std::allocator<GenJet> > -------------------
void __std__vector_GenJet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5984, type_5983), Reflex::Literal("operator="), operator_2901, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2887), Reflex::Literal("assign"), method_2902, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1629), Reflex::Literal("begin"), method_2903, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("begin"), method_2904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1629), Reflex::Literal("end"), method_2905, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1630), Reflex::Literal("end"), method_2906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_6), Reflex::Literal("resize"), method_2913, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2916, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2885, type_1218), Reflex::Literal("operator[]"), operator_2917, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2887, type_1218), Reflex::Literal("operator[]"), operator_2918, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2885, type_1218), Reflex::Literal("at"), method_2920, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2887, type_1218), Reflex::Literal("at"), method_2921, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2885), Reflex::Literal("front"), method_2922, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2887), Reflex::Literal("front"), method_2923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2885), Reflex::Literal("back"), method_2924, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2887), Reflex::Literal("back"), method_2925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2881), Reflex::Literal("data"), method_2926, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2883), Reflex::Literal("data"), method_2927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2887), Reflex::Literal("push_back"), method_2928, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2929, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1629, type_1629, type_2887), Reflex::Literal("insert"), method_2930, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1629, type_1218, type_2887), Reflex::Literal("insert"), method_2931, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1629, type_1629), Reflex::Literal("erase"), method_2932, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1629, type_1629, type_1629), Reflex::Literal("erase"), method_2933, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5984), Reflex::Literal("swap"), method_2934, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_2935, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<Jet,std::allocator<Jet> > -------------------------------
static void constructor_2962( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Jet>();
  else ::new(mem) ::std::vector<Jet>();
}

static void constructor_2963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Jet>(*(const ::std::allocator<Jet>*)arg[0]);
  else ::new(mem) ::std::vector<Jet>(*(const ::std::allocator<Jet>*)arg[0]);
}

static void constructor_2964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Jet>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Jet>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Jet>(*(::std::size_t*)arg[0],
      *(const ::Jet*)arg[1]);
  else ::new(mem) ::std::vector<Jet>(*(::std::size_t*)arg[0],
      *(const ::Jet*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Jet>(*(::std::size_t*)arg[0],
      *(const ::Jet*)arg[1],
      *(const ::std::allocator<Jet>*)arg[2]);
  else ::new(mem) ::std::vector<Jet>(*(::std::size_t*)arg[0],
      *(const ::Jet*)arg[1],
      *(const ::std::allocator<Jet>*)arg[2]);
  }
}

static void constructor_2965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Jet>(*(const ::std::vector<Jet>*)arg[0]);
  else ::new(mem) ::std::vector<Jet>(*(const ::std::vector<Jet>*)arg[0]);
}

static void destructor_2966(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Jet>*)o)->::std::vector<Jet>::~vector)();
}
static  void operator_2967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Jet>*)o)->operator=)(*(const ::std::vector<Jet>*)arg[0]);
  else   (((::std::vector<Jet>*)o)->operator=)(*(const ::std::vector<Jet>*)arg[0]);
}

static  void method_2968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Jet>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::Jet*)arg[1]);
}

static  void method_2969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >)((((::std::vector<Jet>*)o)->begin)());
  else   (((::std::vector<Jet>*)o)->begin)();
}

static  void method_2970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Jet*,std::vector<Jet> >)((((const ::std::vector<Jet>*)o)->begin)());
  else   (((const ::std::vector<Jet>*)o)->begin)();
}

static  void method_2971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >)((((::std::vector<Jet>*)o)->end)());
  else   (((::std::vector<Jet>*)o)->end)();
}

static  void method_2972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Jet*,std::vector<Jet> >)((((const ::std::vector<Jet>*)o)->end)());
  else   (((const ::std::vector<Jet>*)o)->end)();
}

static  void method_2977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Jet>*)o)->size)());
  else   (((const ::std::vector<Jet>*)o)->size)();
}

static  void method_2978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Jet>*)o)->max_size)());
  else   (((const ::std::vector<Jet>*)o)->max_size)();
}

static  void method_2979( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Jet>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Jet>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::Jet*)arg[1]);
  }
}

static  void method_2980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Jet>*)o)->capacity)());
  else   (((const ::std::vector<Jet>*)o)->capacity)();
}

static  void method_2981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Jet>*)o)->empty)());
  else   (((const ::std::vector<Jet>*)o)->empty)();
}

static  void method_2982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Jet>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_2983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_2984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Jet>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_2986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Jet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Jet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Jet>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Jet>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_2988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Jet>*)o)->front)();
  else   (((::std::vector<Jet>*)o)->front)();
}

static  void method_2989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Jet>*)o)->front)();
  else   (((const ::std::vector<Jet>*)o)->front)();
}

static  void method_2990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Jet>*)o)->back)();
  else   (((::std::vector<Jet>*)o)->back)();
}

static  void method_2991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Jet>*)o)->back)();
  else   (((const ::std::vector<Jet>*)o)->back)();
}

static  void method_2992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Jet>*)o)->data)());
  else   (((::std::vector<Jet>*)o)->data)();
}

static  void method_2993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Jet>*)o)->data)());
  else   (((const ::std::vector<Jet>*)o)->data)();
}

static  void method_2994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Jet>*)o)->push_back)(*(const ::Jet*)arg[0]);
}

static  void method_2995( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Jet>*)o)->pop_back)();
}

static  void method_2996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >)((((::std::vector<Jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0],
    *(const ::Jet*)arg[1]));
  else   (((::std::vector<Jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0],
    *(const ::Jet*)arg[1]);
}

static  void method_2997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Jet>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::Jet*)arg[2]);
}

static  void method_2998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >)((((::std::vector<Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0]));
  else   (((::std::vector<Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0]);
}

static  void method_2999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >)((((::std::vector<Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[1]));
  else   (((::std::vector<Jet>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Jet*,std::vector<Jet> >*)arg[1]);
}

static  void method_3000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Jet>*)o)->swap)(*(::std::vector<Jet>*)arg[0]);
}

static  void method_3001( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Jet>*)o)->clear)();
}

static void method_newdel_1032( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Jet,std::allocator<Jet> >")), ::Reflex::BaseOffset< ::std::vector<Jet>,::std::_Vector_base<Jet,std::allocator<Jet> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Jet> >::Generate();
  else ::Reflex::Proxy< ::std::vector<Jet> >::Generate();
}

//------Dictionary for class vector<Jet,std::allocator<Jet> > -------------------------------
void __std__vector_Jet__db_datamem(Reflex::Class*);
void __std__vector_Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Jet__datamem_bld(&__std__vector_Jet__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Jet__funcmem_bld(&__std__vector_Jet__db_funcmem);
void __std__vector_Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Jet>"), typeid(::std::vector<Jet>), sizeof(::std::vector<Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1255, ::Reflex::BaseOffset< ::std::vector<Jet>, ::std::_Vector_base<Jet,std::allocator<Jet> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_277, Reflex::Literal("std::vector<Jet>::_Alloc_value_type"))
  .AddTypedef(type_1255, Reflex::Literal("std::vector<Jet>::_Base"))
  .AddTypedef(type_1145, Reflex::Literal("std::vector<Jet>::_Tp_alloc_type"))
  .AddTypedef(type_1559, Reflex::Literal("std::vector<Jet>::_Alloc_traits"))
  .AddTypedef(type_277, Reflex::Literal("std::vector<Jet>::value_type"))
  .AddTypedef(type_2947, Reflex::Literal("std::vector<Jet>::pointer"))
  .AddTypedef(type_2949, Reflex::Literal("std::vector<Jet>::const_pointer"))
  .AddTypedef(type_2951, Reflex::Literal("std::vector<Jet>::reference"))
  .AddTypedef(type_2953, Reflex::Literal("std::vector<Jet>::const_reference"))
  .AddTypedef(type_1637, Reflex::Literal("std::vector<Jet>::iterator"))
  .AddTypedef(type_1638, Reflex::Literal("std::vector<Jet>::const_iterator"))
  .AddTypedef(type_1233, Reflex::Literal("std::vector<Jet>::const_reverse_iterator"))
  .AddTypedef(type_1234, Reflex::Literal("std::vector<Jet>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<Jet>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<Jet>::difference_type"))
  .AddTypedef(type_1145, Reflex::Literal("std::vector<Jet>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_2962, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5986), Reflex::Literal("vector"), constructor_2963, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2953, type_5986), Reflex::Literal("vector"), constructor_2964, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5987), Reflex::Literal("vector"), constructor_2965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_2966, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1032, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Jet__funcmem_bld);
}

//------Delayed data member builder for class vector<Jet,std::allocator<Jet> > -------------------
void __std__vector_Jet__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Jet,std::allocator<Jet> > -------------------
void __std__vector_Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5988, type_5987), Reflex::Literal("operator="), operator_2967, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2953), Reflex::Literal("assign"), method_2968, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("begin"), method_2969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1638), Reflex::Literal("begin"), method_2970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637), Reflex::Literal("end"), method_2971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1638), Reflex::Literal("end"), method_2972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_2977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_2978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_277), Reflex::Literal("resize"), method_2979, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_2980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_2981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_2982, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_1218), Reflex::Literal("operator[]"), operator_2983, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2953, type_1218), Reflex::Literal("operator[]"), operator_2984, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_1218), Reflex::Literal("at"), method_2986, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2953, type_1218), Reflex::Literal("at"), method_2987, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951), Reflex::Literal("front"), method_2988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2953), Reflex::Literal("front"), method_2989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951), Reflex::Literal("back"), method_2990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2953), Reflex::Literal("back"), method_2991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2947), Reflex::Literal("data"), method_2992, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2949), Reflex::Literal("data"), method_2993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2953), Reflex::Literal("push_back"), method_2994, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_2995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637, type_1637, type_2953), Reflex::Literal("insert"), method_2996, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1637, type_1218, type_2953), Reflex::Literal("insert"), method_2997, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637, type_1637), Reflex::Literal("erase"), method_2998, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1637, type_1637, type_1637), Reflex::Literal("erase"), method_2999, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5988), Reflex::Literal("swap"), method_3000, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_3001, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<void*,std::allocator<void*> > -------------------------------
static void constructor_3027( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<void*>();
  else ::new(mem) ::std::vector<void*>();
}

static void constructor_3028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<void*>(*(const ::std::allocator<void*>*)arg[0]);
  else ::new(mem) ::std::vector<void*>(*(const ::std::allocator<void*>*)arg[0]);
}

static void constructor_3029( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<void*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<void*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<void*>(*(::std::size_t*)arg[0],
      *(void* const*)arg[1]);
  else ::new(mem) ::std::vector<void*>(*(::std::size_t*)arg[0],
      *(void* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<void*>(*(::std::size_t*)arg[0],
      *(void* const*)arg[1],
      *(const ::std::allocator<void*>*)arg[2]);
  else ::new(mem) ::std::vector<void*>(*(::std::size_t*)arg[0],
      *(void* const*)arg[1],
      *(const ::std::allocator<void*>*)arg[2]);
  }
}

static void constructor_3030( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<void*>(*(const ::std::vector<void*>*)arg[0]);
  else ::new(mem) ::std::vector<void*>(*(const ::std::vector<void*>*)arg[0]);
}

static void destructor_3031(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<void*>*)o)->::std::vector<void*>::~vector)();
}
static  void operator_3032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<void*>*)o)->operator=)(*(const ::std::vector<void*>*)arg[0]);
  else   (((::std::vector<void*>*)o)->operator=)(*(const ::std::vector<void*>*)arg[0]);
}

static  void method_3033( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<void*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(void* const*)arg[1]);
}

static  void method_3034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void**,std::vector<void*> >)((((::std::vector<void*>*)o)->begin)());
  else   (((::std::vector<void*>*)o)->begin)();
}

static  void method_3035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void* const*,std::vector<void*> >)((((const ::std::vector<void*>*)o)->begin)());
  else   (((const ::std::vector<void*>*)o)->begin)();
}

static  void method_3036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void**,std::vector<void*> >)((((::std::vector<void*>*)o)->end)());
  else   (((::std::vector<void*>*)o)->end)();
}

static  void method_3037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void* const*,std::vector<void*> >)((((const ::std::vector<void*>*)o)->end)());
  else   (((const ::std::vector<void*>*)o)->end)();
}

static  void method_3042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<void*>*)o)->size)());
  else   (((const ::std::vector<void*>*)o)->size)();
}

static  void method_3043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<void*>*)o)->max_size)());
  else   (((const ::std::vector<void*>*)o)->max_size)();
}

static  void method_3044( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<void*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<void*>*)o)->resize)(*(::std::size_t*)arg[0],
      (void*)arg[1]);
  }
}

static  void method_3045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<void*>*)o)->capacity)());
  else   (((const ::std::vector<void*>*)o)->capacity)();
}

static  void method_3046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<void*>*)o)->empty)());
  else   (((const ::std::vector<void*>*)o)->empty)();
}

static  void method_3047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<void*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<void*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<void*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<void*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<void*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<void*>*)o)->front)();
  else   (((::std::vector<void*>*)o)->front)();
}

static  void method_3054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<void*>*)o)->front)();
  else   (((const ::std::vector<void*>*)o)->front)();
}

static  void method_3055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<void*>*)o)->back)();
  else   (((::std::vector<void*>*)o)->back)();
}

static  void method_3056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<void*>*)o)->back)();
  else   (((const ::std::vector<void*>*)o)->back)();
}

static  void method_3057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<void*>*)o)->data)());
  else   (((::std::vector<void*>*)o)->data)();
}

static  void method_3058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<void*>*)o)->data)());
  else   (((const ::std::vector<void*>*)o)->data)();
}

static  void method_3059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<void*>*)o)->push_back)(*(void* const*)arg[0]);
}

static  void method_3060( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<void*>*)o)->pop_back)();
}

static  void method_3061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void**,std::vector<void*> >)((((::std::vector<void*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0],
    *(void* const*)arg[1]));
  else   (((::std::vector<void*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0],
    *(void* const*)arg[1]);
}

static  void method_3062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<void*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(void* const*)arg[2]);
}

static  void method_3063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void**,std::vector<void*> >)((((::std::vector<void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0]));
  else   (((::std::vector<void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0]);
}

static  void method_3064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<void**,std::vector<void*> >)((((::std::vector<void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[1]));
  else   (((::std::vector<void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<void**,std::vector<void*> >*)arg[1]);
}

static  void method_3065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<void*>*)o)->swap)(*(::std::vector<void*>*)arg[0]);
}

static  void method_3066( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<void*>*)o)->clear)();
}

static void method_newdel_1033( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<void*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<void*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<void*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<void*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<void*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<void*,std::allocator<void*> >")), ::Reflex::BaseOffset< ::std::vector<void*>,::std::_Vector_base<void*,std::allocator<void*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<void*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<void*> >::Generate();
}

//------Dictionary for class vector<void*,std::allocator<void*> > -------------------------------
void __std__vector_voidp__db_datamem(Reflex::Class*);
void __std__vector_voidp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_voidp__datamem_bld(&__std__vector_voidp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_voidp__funcmem_bld(&__std__vector_voidp__db_funcmem);
void __std__vector_voidp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<void*>"), typeid(::std::vector<void*>), sizeof(::std::vector<void*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1259, ::Reflex::BaseOffset< ::std::vector<void*>, ::std::_Vector_base<void*,std::allocator<void*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_263, Reflex::Literal("std::vector<void*>::_Alloc_value_type"))
  .AddTypedef(type_1259, Reflex::Literal("std::vector<void*>::_Base"))
  .AddTypedef(type_1149, Reflex::Literal("std::vector<void*>::_Tp_alloc_type"))
  .AddTypedef(type_1563, Reflex::Literal("std::vector<void*>::_Alloc_traits"))
  .AddTypedef(type_263, Reflex::Literal("std::vector<void*>::value_type"))
  .AddTypedef(type_1508, Reflex::Literal("std::vector<void*>::pointer"))
  .AddTypedef(type_3014, Reflex::Literal("std::vector<void*>::const_pointer"))
  .AddTypedef(type_3016, Reflex::Literal("std::vector<void*>::reference"))
  .AddTypedef(type_3018, Reflex::Literal("std::vector<void*>::const_reference"))
  .AddTypedef(type_1645, Reflex::Literal("std::vector<void*>::iterator"))
  .AddTypedef(type_1646, Reflex::Literal("std::vector<void*>::const_iterator"))
  .AddTypedef(type_1241, Reflex::Literal("std::vector<void*>::const_reverse_iterator"))
  .AddTypedef(type_1242, Reflex::Literal("std::vector<void*>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<void*>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<void*>::difference_type"))
  .AddTypedef(type_1149, Reflex::Literal("std::vector<void*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3027, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5990), Reflex::Literal("vector"), constructor_3028, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_3018, type_5990), Reflex::Literal("vector"), constructor_3029, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5991), Reflex::Literal("vector"), constructor_3030, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3031, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1033, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_voidp__funcmem_bld);
}

//------Delayed data member builder for class vector<void*,std::allocator<void*> > -------------------
void __std__vector_voidp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<void*,std::allocator<void*> > -------------------
void __std__vector_voidp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5992, type_5991), Reflex::Literal("operator="), operator_3032, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_3018), Reflex::Literal("assign"), method_3033, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645), Reflex::Literal("begin"), method_3034, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1646), Reflex::Literal("begin"), method_3035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645), Reflex::Literal("end"), method_3036, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1646), Reflex::Literal("end"), method_3037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_3042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_3043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_263), Reflex::Literal("resize"), method_3044, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_3045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_3046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_3047, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3016, type_1218), Reflex::Literal("operator[]"), operator_3048, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3018, type_1218), Reflex::Literal("operator[]"), operator_3049, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3016, type_1218), Reflex::Literal("at"), method_3051, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3018, type_1218), Reflex::Literal("at"), method_3052, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3016), Reflex::Literal("front"), method_3053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3018), Reflex::Literal("front"), method_3054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3016), Reflex::Literal("back"), method_3055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3018), Reflex::Literal("back"), method_3056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1508), Reflex::Literal("data"), method_3057, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3014), Reflex::Literal("data"), method_3058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_3018), Reflex::Literal("push_back"), method_3059, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_3060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645, type_1645, type_3018), Reflex::Literal("insert"), method_3061, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1645, type_1218, type_3018), Reflex::Literal("insert"), method_3062, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645, type_1645), Reflex::Literal("erase"), method_3063, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1645, type_1645, type_1645), Reflex::Literal("erase"), method_3064, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5992), Reflex::Literal("swap"), method_3065, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_3066, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void constructor_3093( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >();
  else ::new(mem) ::std::vector<std::basic_string<char> >();
}

static void constructor_3094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
}

static void constructor_3095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  }
}

static void constructor_3096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static void destructor_3097(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::basic_string<char> >*)o)->::std::vector<std::basic_string<char> >::~vector)();
}
static  void operator_3098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_3099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_3101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_3102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_3103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_3108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->size)();
}

static  void method_3109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->max_size)();
}

static  void method_3110( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::basic_string<char>*)arg[1]);
  }
}

static  void method_3111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->capacity)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->capacity)();
}

static  void method_3112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->empty)();
}

static  void method_3113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_3120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_3121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_3122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_3123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_3124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_3125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->push_back)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_3126( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->pop_back)();
}

static  void method_3127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_3128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_3129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_3130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]);
}

static  void method_3131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->swap)(*(::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_3132( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->clear)();
}

static void method_newdel_1034( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >")), ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >,::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
}

//------Dictionary for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__datamem_bld(&__std__vector_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__funcmem_bld(&__std__vector_std__basic_string_char_s__db_funcmem);
void __std__vector_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"), typeid(::std::vector<std::basic_string<char> >), sizeof(::std::vector<std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1256, ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >, ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1059, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1256, Reflex::Literal("std::vector<std::basic_string<char> >::_Base"))
  .AddTypedef(type_1147, Reflex::Literal("std::vector<std::basic_string<char> >::_Tp_alloc_type"))
  .AddTypedef(type_1560, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_traits"))
  .AddTypedef(type_1059, Reflex::Literal("std::vector<std::basic_string<char> >::value_type"))
  .AddTypedef(type_3078, Reflex::Literal("std::vector<std::basic_string<char> >::pointer"))
  .AddTypedef(type_3080, Reflex::Literal("std::vector<std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_3082, Reflex::Literal("std::vector<std::basic_string<char> >::reference"))
  .AddTypedef(type_3084, Reflex::Literal("std::vector<std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1640, Reflex::Literal("std::vector<std::basic_string<char> >::iterator"))
  .AddTypedef(type_1641, Reflex::Literal("std::vector<std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1235, Reflex::Literal("std::vector<std::basic_string<char> >::const_reverse_iterator"))
  .AddTypedef(type_1236, Reflex::Literal("std::vector<std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<std::basic_string<char> >::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1147, Reflex::Literal("std::vector<std::basic_string<char> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3093, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5994), Reflex::Literal("vector"), constructor_3094, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_3084, type_5994), Reflex::Literal("vector"), constructor_3095, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5995), Reflex::Literal("vector"), constructor_3096, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3097, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1034, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5996, type_5995), Reflex::Literal("operator="), operator_3098, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_3084), Reflex::Literal("assign"), method_3099, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1640), Reflex::Literal("begin"), method_3100, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1641), Reflex::Literal("begin"), method_3101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1640), Reflex::Literal("end"), method_3102, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1641), Reflex::Literal("end"), method_3103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_3108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_3109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_1059), Reflex::Literal("resize"), method_3110, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_3111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_3112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_3113, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082, type_1218), Reflex::Literal("operator[]"), operator_3114, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084, type_1218), Reflex::Literal("operator[]"), operator_3115, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082, type_1218), Reflex::Literal("at"), method_3117, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084, type_1218), Reflex::Literal("at"), method_3118, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082), Reflex::Literal("front"), method_3119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084), Reflex::Literal("front"), method_3120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3082), Reflex::Literal("back"), method_3121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084), Reflex::Literal("back"), method_3122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3078), Reflex::Literal("data"), method_3123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3080), Reflex::Literal("data"), method_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_3084), Reflex::Literal("push_back"), method_3125, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_3126, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1640, type_1640, type_3084), Reflex::Literal("insert"), method_3127, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1640, type_1218, type_3084), Reflex::Literal("insert"), method_3128, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1640, type_1640), Reflex::Literal("erase"), method_3129, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1640, type_1640, type_1640), Reflex::Literal("erase"), method_3130, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5996), Reflex::Literal("swap"), method_3131, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_3132, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
static void constructor_3156( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>();
  else ::new(mem) ::std::vector<unsigned int>();
}

static void constructor_3157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
}

static void constructor_3158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  }
}

static void constructor_3159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
}

static void destructor_3160(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned int>*)o)->::std::vector<unsigned int>::~vector)();
}
static  void operator_3161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_3162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->begin)());
  else   (((::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->begin)());
  else   (((const ::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->end)());
  else   (((::std::vector<unsigned int>*)o)->end)();
}

static  void method_3166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->end)());
  else   (((const ::std::vector<unsigned int>*)o)->end)();
}

static  void method_3171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->size)());
  else   (((const ::std::vector<unsigned int>*)o)->size)();
}

static  void method_3172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->max_size)());
  else   (((const ::std::vector<unsigned int>*)o)->max_size)();
}

static  void method_3173( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_3174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->capacity)());
  else   (((const ::std::vector<unsigned int>*)o)->capacity)();
}

static  void method_3175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned int>*)o)->empty)());
  else   (((const ::std::vector<unsigned int>*)o)->empty)();
}

static  void method_3176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->front)();
  else   (((::std::vector<unsigned int>*)o)->front)();
}

static  void method_3183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->front)();
  else   (((const ::std::vector<unsigned int>*)o)->front)();
}

static  void method_3184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->back)();
  else   (((::std::vector<unsigned int>*)o)->back)();
}

static  void method_3185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->back)();
  else   (((const ::std::vector<unsigned int>*)o)->back)();
}

static  void method_3186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned int>*)o)->data)());
  else   (((::std::vector<unsigned int>*)o)->data)();
}

static  void method_3187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned int>*)o)->data)());
  else   (((const ::std::vector<unsigned int>*)o)->data)();
}

static  void method_3188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->push_back)(*(const unsigned int*)arg[0]);
}

static  void method_3189( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->pop_back)();
}

static  void method_3190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned int*)arg[2]);
}

static  void method_3192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]);
}

static  void method_3193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void method_3194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->swap)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_3195( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->clear)();
}

static void method_newdel_1035( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >")), ::Reflex::BaseOffset< ::std::vector<unsigned int>,::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x49( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
}

//------Dictionary for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*);
void __std__vector_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__datamem_bld(&__std__vector_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__funcmem_bld(&__std__vector_unsignedsint__db_funcmem);
void __std__vector_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned int>"), typeid(::std::vector<unsigned int>), sizeof(::std::vector<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1257, ::Reflex::BaseOffset< ::std::vector<unsigned int>, ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_85, Reflex::Literal("std::vector<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1257, Reflex::Literal("std::vector<unsigned int>::_Base"))
  .AddTypedef(type_1146, Reflex::Literal("std::vector<unsigned int>::_Tp_alloc_type"))
  .AddTypedef(type_1561, Reflex::Literal("std::vector<unsigned int>::_Alloc_traits"))
  .AddTypedef(type_85, Reflex::Literal("std::vector<unsigned int>::value_type"))
  .AddTypedef(type_1940, Reflex::Literal("std::vector<unsigned int>::pointer"))
  .AddTypedef(type_2518, Reflex::Literal("std::vector<unsigned int>::const_pointer"))
  .AddTypedef(type_3146, Reflex::Literal("std::vector<unsigned int>::reference"))
  .AddTypedef(type_2520, Reflex::Literal("std::vector<unsigned int>::const_reference"))
  .AddTypedef(type_1642, Reflex::Literal("std::vector<unsigned int>::iterator"))
  .AddTypedef(type_1639, Reflex::Literal("std::vector<unsigned int>::const_iterator"))
  .AddTypedef(type_1237, Reflex::Literal("std::vector<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_1238, Reflex::Literal("std::vector<unsigned int>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<unsigned int>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<unsigned int>::difference_type"))
  .AddTypedef(type_1146, Reflex::Literal("std::vector<unsigned int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3156, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5997), Reflex::Literal("vector"), constructor_3157, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_2520, type_5997), Reflex::Literal("vector"), constructor_3158, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5998), Reflex::Literal("vector"), constructor_3159, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3160, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1035, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5999, type_5998), Reflex::Literal("operator="), operator_3161, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_2520), Reflex::Literal("assign"), method_3162, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1642), Reflex::Literal("begin"), method_3163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1639), Reflex::Literal("begin"), method_3164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1642), Reflex::Literal("end"), method_3165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1639), Reflex::Literal("end"), method_3166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_3171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_3172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_85), Reflex::Literal("resize"), method_3173, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_3174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_3175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_3176, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3146, type_1218), Reflex::Literal("operator[]"), operator_3177, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520, type_1218), Reflex::Literal("operator[]"), operator_3178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3146, type_1218), Reflex::Literal("at"), method_3180, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520, type_1218), Reflex::Literal("at"), method_3181, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3146), Reflex::Literal("front"), method_3182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520), Reflex::Literal("front"), method_3183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3146), Reflex::Literal("back"), method_3184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520), Reflex::Literal("back"), method_3185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1940), Reflex::Literal("data"), method_3186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2518), Reflex::Literal("data"), method_3187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_2520), Reflex::Literal("push_back"), method_3188, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_3189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1642, type_1642, type_2520), Reflex::Literal("insert"), method_3190, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1642, type_1218, type_2520), Reflex::Literal("insert"), method_3191, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1642, type_1642), Reflex::Literal("erase"), method_3192, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1642, type_1642, type_1642), Reflex::Literal("erase"), method_3193, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_5999), Reflex::Literal("swap"), method_3194, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_3195, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > -------------------------------
static void constructor_3223( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<albers::CollectionBase*>();
  else ::new(mem) ::std::vector<albers::CollectionBase*>();
}

static void constructor_3224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<albers::CollectionBase*>(*(const ::std::allocator<albers::CollectionBase*>*)arg[0]);
  else ::new(mem) ::std::vector<albers::CollectionBase*>(*(const ::std::allocator<albers::CollectionBase*>*)arg[0]);
}

static void constructor_3225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<albers::CollectionBase*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<albers::CollectionBase*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<albers::CollectionBase*>(*(::std::size_t*)arg[0],
      *(::albers::CollectionBase* const*)arg[1]);
  else ::new(mem) ::std::vector<albers::CollectionBase*>(*(::std::size_t*)arg[0],
      *(::albers::CollectionBase* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<albers::CollectionBase*>(*(::std::size_t*)arg[0],
      *(::albers::CollectionBase* const*)arg[1],
      *(const ::std::allocator<albers::CollectionBase*>*)arg[2]);
  else ::new(mem) ::std::vector<albers::CollectionBase*>(*(::std::size_t*)arg[0],
      *(::albers::CollectionBase* const*)arg[1],
      *(const ::std::allocator<albers::CollectionBase*>*)arg[2]);
  }
}

static void constructor_3226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<albers::CollectionBase*>(*(const ::std::vector<albers::CollectionBase*>*)arg[0]);
  else ::new(mem) ::std::vector<albers::CollectionBase*>(*(const ::std::vector<albers::CollectionBase*>*)arg[0]);
}

static void destructor_3227(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<albers::CollectionBase*>*)o)->::std::vector<albers::CollectionBase*>::~vector)();
}
static  void operator_3228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<albers::CollectionBase*>*)o)->operator=)(*(const ::std::vector<albers::CollectionBase*>*)arg[0]);
  else   (((::std::vector<albers::CollectionBase*>*)o)->operator=)(*(const ::std::vector<albers::CollectionBase*>*)arg[0]);
}

static  void method_3229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::albers::CollectionBase* const*)arg[1]);
}

static  void method_3230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >)((((::std::vector<albers::CollectionBase*>*)o)->begin)());
  else   (((::std::vector<albers::CollectionBase*>*)o)->begin)();
}

static  void method_3231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase* const*,std::vector<albers::CollectionBase*> >)((((const ::std::vector<albers::CollectionBase*>*)o)->begin)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->begin)();
}

static  void method_3232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >)((((::std::vector<albers::CollectionBase*>*)o)->end)());
  else   (((::std::vector<albers::CollectionBase*>*)o)->end)();
}

static  void method_3233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase* const*,std::vector<albers::CollectionBase*> >)((((const ::std::vector<albers::CollectionBase*>*)o)->end)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->end)();
}

static  void method_3238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<albers::CollectionBase*>*)o)->size)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->size)();
}

static  void method_3239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<albers::CollectionBase*>*)o)->max_size)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->max_size)();
}

static  void method_3240( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<albers::CollectionBase*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<albers::CollectionBase*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::albers::CollectionBase*)arg[1]);
  }
}

static  void method_3241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<albers::CollectionBase*>*)o)->capacity)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->capacity)();
}

static  void method_3242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<albers::CollectionBase*>*)o)->empty)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->empty)();
}

static  void method_3243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<albers::CollectionBase*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<albers::CollectionBase*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<albers::CollectionBase*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<albers::CollectionBase*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<albers::CollectionBase*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<albers::CollectionBase*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<albers::CollectionBase*>*)o)->front)();
  else   (((::std::vector<albers::CollectionBase*>*)o)->front)();
}

static  void method_3250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<albers::CollectionBase*>*)o)->front)();
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->front)();
}

static  void method_3251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<albers::CollectionBase*>*)o)->back)();
  else   (((::std::vector<albers::CollectionBase*>*)o)->back)();
}

static  void method_3252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<albers::CollectionBase*>*)o)->back)();
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->back)();
}

static  void method_3253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<albers::CollectionBase*>*)o)->data)());
  else   (((::std::vector<albers::CollectionBase*>*)o)->data)();
}

static  void method_3254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<albers::CollectionBase*>*)o)->data)());
  else   (((const ::std::vector<albers::CollectionBase*>*)o)->data)();
}

static  void method_3255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->push_back)(*(::albers::CollectionBase* const*)arg[0]);
}

static  void method_3256( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->pop_back)();
}

static  void method_3257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >)((((::std::vector<albers::CollectionBase*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0],
    *(::albers::CollectionBase* const*)arg[1]));
  else   (((::std::vector<albers::CollectionBase*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0],
    *(::albers::CollectionBase* const*)arg[1]);
}

static  void method_3258( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::albers::CollectionBase* const*)arg[2]);
}

static  void method_3259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >)((((::std::vector<albers::CollectionBase*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0]));
  else   (((::std::vector<albers::CollectionBase*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0]);
}

static  void method_3260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >)((((::std::vector<albers::CollectionBase*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[1]));
  else   (((::std::vector<albers::CollectionBase*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<albers::CollectionBase**,std::vector<albers::CollectionBase*> >*)arg[1]);
}

static  void method_3261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->swap)(*(::std::vector<albers::CollectionBase*>*)arg[0]);
}

static  void method_3262( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<albers::CollectionBase*>*)o)->clear)();
}

static void method_newdel_1036( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<albers::CollectionBase*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<albers::CollectionBase*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<albers::CollectionBase*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<albers::CollectionBase*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<albers::CollectionBase*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x51( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<albers::CollectionBase*,std::allocator<albers::CollectionBase*> >")), ::Reflex::BaseOffset< ::std::vector<albers::CollectionBase*>,::std::_Vector_base<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<albers::CollectionBase*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<albers::CollectionBase*> >::Generate();
}

//------Dictionary for class vector<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > -------------------------------
void __std__vector_albers__CollectionBasep__db_datamem(Reflex::Class*);
void __std__vector_albers__CollectionBasep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_albers__CollectionBasep__datamem_bld(&__std__vector_albers__CollectionBasep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_albers__CollectionBasep__funcmem_bld(&__std__vector_albers__CollectionBasep__db_funcmem);
void __std__vector_albers__CollectionBasep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<albers::CollectionBase*>"), typeid(::std::vector<albers::CollectionBase*>), sizeof(::std::vector<albers::CollectionBase*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("n_pattern"), "std::vector<*>")
  .AddBase(type_1258, ::Reflex::BaseOffset< ::std::vector<albers::CollectionBase*>, ::std::_Vector_base<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3202, Reflex::Literal("std::vector<albers::CollectionBase*>::_Alloc_value_type"))
  .AddTypedef(type_1258, Reflex::Literal("std::vector<albers::CollectionBase*>::_Base"))
  .AddTypedef(type_1148, Reflex::Literal("std::vector<albers::CollectionBase*>::_Tp_alloc_type"))
  .AddTypedef(type_1562, Reflex::Literal("std::vector<albers::CollectionBase*>::_Alloc_traits"))
  .AddTypedef(type_3202, Reflex::Literal("std::vector<albers::CollectionBase*>::value_type"))
  .AddTypedef(type_3208, Reflex::Literal("std::vector<albers::CollectionBase*>::pointer"))
  .AddTypedef(type_3210, Reflex::Literal("std::vector<albers::CollectionBase*>::const_pointer"))
  .AddTypedef(type_3212, Reflex::Literal("std::vector<albers::CollectionBase*>::reference"))
  .AddTypedef(type_3214, Reflex::Literal("std::vector<albers::CollectionBase*>::const_reference"))
  .AddTypedef(type_1643, Reflex::Literal("std::vector<albers::CollectionBase*>::iterator"))
  .AddTypedef(type_1644, Reflex::Literal("std::vector<albers::CollectionBase*>::const_iterator"))
  .AddTypedef(type_1239, Reflex::Literal("std::vector<albers::CollectionBase*>::const_reverse_iterator"))
  .AddTypedef(type_1240, Reflex::Literal("std::vector<albers::CollectionBase*>::reverse_iterator"))
  .AddTypedef(type_1218, Reflex::Literal("std::vector<albers::CollectionBase*>::size_type"))
  .AddTypedef(type_1176, Reflex::Literal("std::vector<albers::CollectionBase*>::difference_type"))
  .AddTypedef(type_1148, Reflex::Literal("std::vector<albers::CollectionBase*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3223, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6001), Reflex::Literal("vector"), constructor_3224, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1218, type_3214, type_6001), Reflex::Literal("vector"), constructor_3225, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6002), Reflex::Literal("vector"), constructor_3226, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3227, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1036, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x51, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_albers__CollectionBasep__funcmem_bld);
}

//------Delayed data member builder for class vector<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > -------------------
void __std__vector_albers__CollectionBasep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<albers::CollectionBase*,std::allocator<albers::CollectionBase*> > -------------------
void __std__vector_albers__CollectionBasep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6003, type_6002), Reflex::Literal("operator="), operator_3228, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_3214), Reflex::Literal("assign"), method_3229, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1643), Reflex::Literal("begin"), method_3230, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1644), Reflex::Literal("begin"), method_3231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1643), Reflex::Literal("end"), method_3232, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1644), Reflex::Literal("end"), method_3233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("size"), method_3238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("max_size"), method_3239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218, type_3202), Reflex::Literal("resize"), method_3240, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1218), Reflex::Literal("capacity"), method_3241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1424), Reflex::Literal("empty"), method_3242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1218), Reflex::Literal("reserve"), method_3243, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3212, type_1218), Reflex::Literal("operator[]"), operator_3244, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_1218), Reflex::Literal("operator[]"), operator_3245, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3212, type_1218), Reflex::Literal("at"), method_3247, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214, type_1218), Reflex::Literal("at"), method_3248, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3212), Reflex::Literal("front"), method_3249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("front"), method_3250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3212), Reflex::Literal("back"), method_3251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3214), Reflex::Literal("back"), method_3252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3208), Reflex::Literal("data"), method_3253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3210), Reflex::Literal("data"), method_3254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_3214), Reflex::Literal("push_back"), method_3255, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("pop_back"), method_3256, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1643, type_1643, type_3214), Reflex::Literal("insert"), method_3257, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_1643, type_1218, type_3214), Reflex::Literal("insert"), method_3258, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1643, type_1643), Reflex::Literal("erase"), method_3259, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1643, type_1643, type_1643), Reflex::Literal("erase"), method_3260, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_6003), Reflex::Literal("swap"), method_3261, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("clear"), method_3262, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Registry -------------------------------
static void destructor_4966(void*, void * o, const std::vector<void*>&, void *) {
(((::albers::Registry*)o)->::albers::Registry::~Registry)();
}
static  void operator_4967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::albers::Registry*)o)->operator=)(*(const ::albers::Registry*)arg[0]);
  else   (((::albers::Registry*)o)->operator=)(*(const ::albers::Registry*)arg[0]);
}

static void constructor_4968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::albers::Registry(*(const ::albers::Registry*)arg[0]);
  else ::new(mem) ::albers::Registry(*(const ::albers::Registry*)arg[0]);
}

static void constructor_4969( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::albers::Registry();
  else ::new(mem) ::albers::Registry();
}

static  void method_4970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::albers::Registry*)o)->getNameFromID)(*(unsigned int*)arg[0]));
  else   (((const ::albers::Registry*)o)->getNameFromID)(*(unsigned int*)arg[0]);
}

static  void method_4971( void*, void* o, const std::vector<void*>&, void*)
{
  (((::albers::Registry*)o)->resetAddresses)();
}

static  void method_4972( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::albers::Registry*)o)->setReader)((::albers::Reader*)arg[0]);
}

static  void method_4973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::albers::Registry*)o)->reader)());
  else   (((::albers::Registry*)o)->reader)();
}

static  void method_4974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::albers::Registry*)o)->names)();
  else   (((::albers::Registry*)o)->names)();
}

static  void method_4975( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::albers::Registry*)o)->print)();
}

static void method_newdel_1537( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::albers::Registry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::albers::Registry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::albers::Registry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::albers::Registry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::albers::Registry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Registry -------------------------------
void __albers__Registry_db_datamem(Reflex::Class*);
void __albers__Registry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __albers__Registry_datamem_bld(&__albers__Registry_db_datamem);
Reflex::GenreflexMemberBuilder __albers__Registry_funcmem_bld(&__albers__Registry_db_funcmem);
void __albers__Registry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("albers::Registry"), typeid(::albers::Registry), sizeof(::albers::Registry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Registry"), destructor_4966, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6458, type_6459), Reflex::Literal("operator="), operator_4967, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6459), Reflex::Literal("Registry"), constructor_4968, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Registry"), constructor_4969, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1537, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__albers__Registry_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__albers__Registry_funcmem_bld);
}

//------Delayed data member builder for class Registry -------------------
void __albers__Registry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1033, Reflex::Literal("m_addresses"), OffsetOf(__shadow__::__albers__Registry, m_addresses), ::Reflex::PRIVATE)
  .AddDataMember(type_1036, Reflex::Literal("m_collections"), OffsetOf(__shadow__::__albers__Registry, m_collections), ::Reflex::PRIVATE)
  .AddDataMember(type_1035, Reflex::Literal("m_collectionIDs"), OffsetOf(__shadow__::__albers__Registry, m_collectionIDs), ::Reflex::PRIVATE)
  .AddDataMember(type_1034, Reflex::Literal("m_names"), OffsetOf(__shadow__::__albers__Registry, m_names), ::Reflex::PRIVATE)
  .AddDataMember(type_6457, Reflex::Literal("m_reader"), OffsetOf(__shadow__::__albers__Registry, m_reader), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class Registry -------------------
void __albers__Registry_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1072, type_85), Reflex::Literal("getNameFromID"), method_4970, 0, "ID", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("resetAddresses"), method_4971, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523, type_6457), Reflex::Literal("setReader"), method_4972, 0, "reader", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6457), Reflex::Literal("reader"), method_4973, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5996), Reflex::Literal("names"), method_4974, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1523), Reflex::Literal("print"), method_4975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __GenJet_dict(); 
      __Particle_dict(); 
      __MCParticle_dict(); 
      __JetHandle_dict(); 
      __JetParticleAssociationHandle_dict(); 
      __LorentzVector_dict(); 
      __BareCluster_dict(); 
      __Jet_dict(); 
      __EventInfoHandle_dict(); 
      __MCParticleHandle_dict(); 
      __GenJetParticleAssociation_dict(); 
      __Point_dict(); 
      __BareJet_dict(); 
      __JetParticleAssociation_dict(); 
      __BareParticle_dict(); 
      __GenJetHandle_dict(); 
      __EventInfo_dict(); 
      __BareHit_dict(); 
      __ParticleHandle_dict(); 
      __GenJetParticleAssociationHandle_dict(); 
      __std__vector_GenJetParticleAssociation__dict(); 
      __std__vector_JetParticleAssociation__dict(); 
      __std__vector_MCParticle__dict(); 
      __std__vector_Particle__dict(); 
      __std__vector_EventInfo__dict(); 
      __std__vector_GenJet__dict(); 
      __std__vector_Jet__dict(); 
      __std__vector_voidp__dict(); 
      __std__vector_std__basic_string_char_s__dict(); 
      __std__vector_unsignedsint__dict(); 
      __std__vector_albers__CollectionBasep__dict(); 
      __albers__Registry_dict(); 
    }
    ~Dictionaries() {
      type_6.Unload(); // class GenJet 
      type_77.Unload(); // class Particle 
      type_119.Unload(); // class MCParticle 
      type_201.Unload(); // class JetHandle 
      type_229.Unload(); // class JetParticleAssociationHandle 
      type_261.Unload(); // class LorentzVector 
      type_270.Unload(); // class BareCluster 
      type_277.Unload(); // class Jet 
      type_296.Unload(); // class EventInfoHandle 
      type_315.Unload(); // class MCParticleHandle 
      type_370.Unload(); // class GenJetParticleAssociation 
      type_408.Unload(); // class Point 
      type_416.Unload(); // class BareJet 
      type_529.Unload(); // class JetParticleAssociation 
      type_534.Unload(); // class BareParticle 
      type_626.Unload(); // class GenJetHandle 
      type_779.Unload(); // class EventInfo 
      type_782.Unload(); // class BareHit 
      type_913.Unload(); // class ParticleHandle 
      type_954.Unload(); // class GenJetParticleAssociationHandle 
      type_1026.Unload(); // class std::vector<GenJetParticleAssociation> 
      type_1027.Unload(); // class std::vector<JetParticleAssociation> 
      type_1028.Unload(); // class std::vector<MCParticle> 
      type_1029.Unload(); // class std::vector<Particle> 
      type_1030.Unload(); // class std::vector<EventInfo> 
      type_1031.Unload(); // class std::vector<GenJet> 
      type_1032.Unload(); // class std::vector<Jet> 
      type_1033.Unload(); // class std::vector<void*> 
      type_1034.Unload(); // class std::vector<std::basic_string<char> > 
      type_1035.Unload(); // class std::vector<unsigned int> 
      type_1036.Unload(); // class std::vector<albers::CollectionBase*> 
      type_1537.Unload(); // class albers::Registry 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
